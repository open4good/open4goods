name: Assign Issues to GitHub Projects V2

on:
  issues:
    types: [opened, labeled, unlabeled]
  workflow_dispatch:

env:
  ORG_NAME: open4good
  PROJECT_ID_MAPPING: |
    squad:pmo=PVT_kwDOBOJOp84A8tDc
    squad:ux=PVT_kwDOBOJOp84A2ZQ8
    squad:backend=PVT_kwDOBOJOp84A2ZRZ
    squad:exposition=PVT_kwDOBOJOp84A83dE
    EPIC=PVT_kwDOBOJOp84A8tDc
    USERSTORY=PVT_kwDOBOJOp84A8tDc
    RISKY=PVT_kwDOBOJOp84A8tDc
  PMO_PROJECT_ID: PVT_kwDOBOJOp84A8tDc
  PMO_STATUS_FIELD_ID: ${{ secrets.PMO_STATUS_FIELD_ID }}
  PMO_TRIAGE_OPTION_ID: ${{ secrets.PMO_TRIAGE_OPTION_ID }}

jobs:
  assign-on-event:
    if: github.event_name == 'issues'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          script: |
            const mapping = Object.fromEntries(
              process.env.PROJECT_ID_MAPPING
                .trim()
                .split('\n')
                .map(l => l.trim().split('='))
            );
            const PMO_PROJECT_ID = process.env.PMO_PROJECT_ID;
            const issue   = context.payload.issue;
            const labels  = issue.labels.map(l => l.name);
            const action  = context.payload.action;           // 'labeled' | 'unlabeled' | 'opened'
            const labelName = context.payload.label?.name || null;
            const isSquad = (n) => n.startsWith('squad:');

            async function removeFromProject(projectId, contentId) {
              const q = await github.graphql(
                `query($contentId: ID!) {
                  node(id: $contentId) {
                    ... on Issue {
                      projectItems(first: 50, includeArchived: true) {
                        nodes { id project { id } }
                      }
                    }
                    ... on PullRequest {
                      projectItems(first: 50, includeArchived: true) {
                        nodes { id project { id } }
                      }
                    }
                  }
                }`,
                { contentId }
              );
              const items = q.node?.projectItems?.nodes || [];
              for (const it of items.filter(n => n.project.id === projectId)) {
                await github.graphql(
                  `mutation($projectId: ID!, $itemId: ID!) {
                    deleteProjectV2Item(input: { projectId: $projectId, itemId: $itemId }) {
                      deletedItemId
                    }
                  }`,
                  { projectId, itemId: it.id }
                );
                console.log(`Removed item ${it.id} from project ${projectId}.`);
              }
            }

            async function addToProject(projectId, contentId) {
              try {
                const res = await github.graphql(
                  `mutation($projectId: ID!, $contentId: ID!) {
                    addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                      item { id }
                    }
                  }`,
                  { projectId, contentId }
                );
                console.log(`Added to project ${projectId}: item ${res.addProjectV2ItemById.item.id}`);
              } catch (e) {
                console.log(`Unable to add to project ${projectId}: ${e.message}`);
              }
            }

            // --- 1. Action-specific handling for squad labels ---
            if (labelName && mapping[labelName] && isSquad(labelName)) {
              if (action === 'labeled') {
                // Add to the new squad project
                await addToProject(mapping[labelName], issue.node_id);

                // Remove from ALL other squad projects to simulate "move"
                for (const [lbl, projId] of Object.entries(mapping)) {
                  if (isSquad(lbl) && lbl !== labelName) {
                    await removeFromProject(projId, issue.node_id);
                  }
                }
              } else if (action === 'unlabeled') {
                // Remove from the squad project that was just removed
                await removeFromProject(mapping[labelName], issue.node_id);
              }
            }

            // --- 2. Add to project for non-squad labels ONLY on "labeled" ---
            if (labelName && mapping[labelName] && !isSquad(labelName) && action === 'labeled') {
              await addToProject(mapping[labelName], issue.node_id);
            }

            // --- 3. PMO routing logic ---
            const hasSquad = labels.some(isSquad);
            const hasEpic  = labels.includes('EPIC');

            if (!hasSquad || hasEpic) {
              // Ensure it's in PMO + set status to TRIAGE
              const addRes = await github.graphql(
                `mutation($projectId: ID!, $contentId: ID!) {
                  addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                    item { id }
                  }
                }`,
                { projectId: PMO_PROJECT_ID, contentId: issue.node_id }
              );
              const itemId = addRes.addProjectV2ItemById.item.id;

              await github.graphql(
                `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId,
                    itemId: $itemId,
                    fieldId: $fieldId,
                    value: { singleSelectOptionId: $optionId }
                  }) { item { id } }
                }`,
                {
                  projectId: PMO_PROJECT_ID,
                  itemId,
                  fieldId: process.env.PMO_STATUS_FIELD_ID,
                  optionId: process.env.PMO_TRIAGE_OPTION_ID,
                }
              );
              console.log(`Issue #${issue.number} routed to PMO project.`);
            } else {
              // hasSquad && !hasEpic -> ensure it's NOT in PMO
              await removeFromProject(PMO_PROJECT_ID, issue.node_id);
            }

  bulk-assign-on-dispatch:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          script: |
            const mapping = Object.fromEntries(
              process.env.PROJECT_ID_MAPPING
                .trim()
                .split('\n')
                .map(l => l.trim().split('='))
            );
            const PMO_PROJECT_ID = process.env.PMO_PROJECT_ID;
            const isSquad = (n) => n.startsWith('squad:');

            async function removeFromProject(projectId, contentId) {
              const q = await github.graphql(
                `query($contentId: ID!) {
                  node(id: $contentId) {
                    ... on Issue {
                      projectItems(first: 50, includeArchived: true) {
                        nodes { id project { id } }
                      }
                    }
                    ... on PullRequest {
                      projectItems(first: 50, includeArchived: true) {
                        nodes { id project { id } }
                      }
                    }
                  }
                }`,
                { contentId }
              );
              const items = q.node?.projectItems?.nodes || [];
              for (const it of items.filter(n => n.project.id === projectId)) {
                await github.graphql(
                  `mutation($projectId: ID!, $itemId: ID!) {
                    deleteProjectV2Item(input: { projectId: $projectId, itemId: $itemId }) {
                      deletedItemId
                    }
                  }`,
                  { projectId, itemId: it.id }
                );
                console.log(`Removed item ${it.id} from project ${projectId}.`);
              }
            }

            async function addToProject(projectId, contentId) {
              try {
                const res = await github.graphql(
                  `mutation($projectId: ID!, $contentId: ID!) {
                    addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                      item { id }
                    }
                  }`,
                  { projectId, contentId }
                );
                console.log(`Added to project ${projectId}: item ${res.addProjectV2ItemById.item.id}`);
              } catch (e) {
                console.log(`Unable to add to project ${projectId}: ${e.message}`);
              }
            }

            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner: context.repo.owner, repo: context.repo.repo, state: 'open', per_page: 100 }
            );

            for (const issue of issues) {
              if (issue.pull_request) continue;

              const labels = issue.labels.map(l => l.name);
              const hasSquad = labels.some(isSquad);
              const hasEpic  = labels.includes('EPIC');

              // Determine the single squad label to keep (first one found)
              const squadLabel = labels.find(isSquad);

              // 1. Ensure item is in the correct squad project (if any)
              if (squadLabel && mapping[squadLabel]) {
                await addToProject(mapping[squadLabel], issue.node_id);
                // Remove from all other squad projects
                for (const [lbl, projId] of Object.entries(mapping)) {
                  if (isSquad(lbl) && lbl !== squadLabel) {
                    await removeFromProject(projId, issue.node_id);
                  }
                }
              } else {
                // Remove from every squad project since there is no squad label
                for (const [lbl, projId] of Object.entries(mapping)) {
                  if (isSquad(lbl)) {
                    await removeFromProject(projId, issue.node_id);
                  }
                }
              }

              // 2. Ensure PMO state
              if (!hasSquad || hasEpic) {
                try {
                  const addRes = await github.graphql(
                    `mutation($projectId: ID!, $contentId: ID!) {
                      addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                        item { id }
                      }
                    }`,
                    { projectId: PMO_PROJECT_ID, contentId: issue.node_id }
                  );
                  const itemId = addRes.addProjectV2ItemById.item.id;

                  await github.graphql(
                    `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                      updateProjectV2ItemFieldValue(input: {
                        projectId: $projectId,
                        itemId: $itemId,
                        fieldId: $fieldId,
                        value: { singleSelectOptionId: $optionId }
                      }) { item { id } }
                    }`,
                    {
                      projectId: PMO_PROJECT_ID,
                      itemId,
                      fieldId: process.env.PMO_STATUS_FIELD_ID,
                      optionId: process.env.PMO_TRIAGE_OPTION_ID,
                    }
                  );
                  console.log(`Issue #${issue.number} routed to PMO project.`);
                } catch (e) {
                  console.log(`Error routing issue #${issue.number} to PMO: ${e.message}`);
                }
              } else {
                await removeFromProject(PMO_PROJECT_ID, issue.node_id);
              }
            }
