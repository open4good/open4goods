name: Assign Issues to GitHub Projects V2

on:
  issues:
    types: [opened, labeled, unlabeled]
  workflow_dispatch:

env:
  ORG_NAME: open4good
  PROJECT_ID_MAPPING: |
    squad:pmo=PVT_kwDOBOJOp84A8tDc
    EPIC=PVT_kwDOBOJOp84A8tDc
    RISKY=PVT_kwDOBOJOp84A8tDc
    squad:ux=PVT_kwDOBOJOp84A2ZQ8
    squad:backend=PVT_kwDOBOJOp84A2ZRZ
    squad:exposition=PVT_kwDOBOJOp84A83dE
  PMO_PROJECT_ID: PVT_kwDOBOJOp84A8tDc
  PMO_STATUS_FIELD_ID: ${{ secrets.PMO_STATUS_FIELD_ID }}
  PMO_TRIAGE_OPTION_ID: ${{ secrets.PMO_TRIAGE_OPTION_ID }}

jobs:
  assign-on-event:
    if: github.event_name == 'issues'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          script: |
            const mapping = Object.fromEntries(
              process.env.PROJECT_ID_MAPPING
                .trim()
                .split('\n')
                .map(l => l.trim().split('='))
            );

            const PMO_PROJECT_ID = process.env.PMO_PROJECT_ID;

            async function removeFromProject(projectId, contentId) {
              const q = await github.graphql(
                `query($contentId: ID!) {
                  node(id: $contentId) {
                    ... on Issue {
                      projectItems(first: 50, includeArchived: true) {
                        nodes { id project { id } }
                      }
                    }
                    ... on PullRequest {
                      projectItems(first: 50, includeArchived: true) {
                        nodes { id project { id } }
                      }
                    }
                  }
                }`,
                { contentId }
              );

              const items = q.node?.projectItems?.nodes || [];
              for (const it of items.filter(n => n.project.id === projectId)) {
                await github.graphql(
                  `mutation($projectId: ID!, $itemId: ID!) {
                    deleteProjectV2Item(input: { projectId: $projectId, itemId: $itemId }) {
                      deletedItemId
                    }
                  }`,
                  { projectId, itemId: it.id }
                );
                console.log(`Removed item ${it.id} from project ${projectId}.`);
              }
            }

            const issue = context.payload.issue;
            const labels = issue.labels.map(l => l.name);
            const hasSquad = labels.some(n => n.startsWith('squad:'));
            const hasEpic  = labels.includes('EPIC');
            const labelName = context.payload.action === 'labeled' ? context.payload.label.name
                             : context.payload.action === 'unlabeled' ? context.payload.label.name
                             : null;

            // 1. Add to specific project when the triggering label matches mapping
            if (labelName && mapping[labelName]) {
              const projectId = mapping[labelName];
              try {
                await github.graphql(
                  `mutation($projectId: ID!, $contentId: ID!) {
                    addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                      item { id }
                    }
                  }`,
                  { projectId, contentId: issue.node_id }
                );
                console.log(`Issue #${issue.number} added to project ID ${projectId}.`);
              } catch (e) {
                console.log(`Unable to add to project ${projectId}: ${e.message}`);
              }
            }

            // 2. PMO routing logic
            if (!hasSquad || hasEpic) {
              // Ensure it's in PMO + set status to TRIAGE
              const addRes = await github.graphql(
                `mutation($projectId: ID!, $contentId: ID!) {
                  addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                    item { id }
                  }
                }`,
                { projectId: PMO_PROJECT_ID, contentId: issue.node_id }
              );
              const itemId = addRes.addProjectV2ItemById.item.id;

              await github.graphql(
                `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId,
                    itemId: $itemId,
                    fieldId: $fieldId,
                    value: { singleSelectOptionId: $optionId }
                  }) { item { id } }
                }`,
                {
                  projectId: PMO_PROJECT_ID,
                  itemId,
                  fieldId: process.env.PMO_STATUS_FIELD_ID,
                  optionId: process.env.PMO_TRIAGE_OPTION_ID,
                }
              );
              console.log(`Issue #${issue.number} routed to PMO project.`);
            } else {
              // hasSquad && !hasEpic -> ensure it's NOT in PMO
              await removeFromProject(PMO_PROJECT_ID, issue.node_id);
            }

  bulk-assign-on-dispatch:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          script: |
            const mapping = Object.fromEntries(
              process.env.PROJECT_ID_MAPPING
                .trim()
                .split('\n')
                .map(l => l.trim().split('='))
            );

            const PMO_PROJECT_ID = process.env.PMO_PROJECT_ID;

            async function removeFromProject(projectId, contentId) {
              const q = await github.graphql(
                `query($contentId: ID!) {
                  node(id: $contentId) {
                    ... on Issue {
                      projectItems(first: 50, includeArchived: true) {
                        nodes { id project { id } }
                      }
                    }
                    ... on PullRequest {
                      projectItems(first: 50, includeArchived: true) {
                        nodes { id project { id } }
                      }
                    }
                  }
                }`,
                { contentId }
              );
              const items = q.node?.projectItems?.nodes || [];
              for (const it of items.filter(n => n.project.id === projectId)) {
                await github.graphql(
                  `mutation($projectId: ID!, $itemId: ID!) {
                    deleteProjectV2Item(input: { projectId: $projectId, itemId: $itemId }) {
                      deletedItemId
                    }
                  }`,
                  { projectId, itemId: it.id }
                );
                console.log(`Removed item ${it.id} from project ${projectId}.`);
              }
            }

            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner: context.repo.owner, repo: context.repo.repo, state: 'open', per_page: 100 }
            );

            for (const issue of issues) {
              if (issue.pull_request) continue;

              const labels = issue.labels.map(l => l.name);
              const hasSquad = labels.some(n => n.startsWith('squad:'));
              const hasEpic  = labels.includes('EPIC');

              let assigned = false;
              for (const label of labels) {
                if (mapping[label]) {
                  const projectId = mapping[label];
                  try {
                    await github.graphql(
                      `mutation($projectId: ID!, $contentId: ID!) {
                        addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                          item { id }
                        }
                      }`,
                      { projectId, contentId: issue.node_id }
                    );
                    console.log(`Issue #${issue.number} added to project ID ${projectId}.`);
                    assigned = true;
                    break;
                  } catch (e) {
                    console.log(`Unable to add issue #${issue.number} to project ${projectId}: ${e.message}`);
                  }
                }
              }

              if (!assigned && (!hasSquad || hasEpic)) {
                try {
                  const addRes = await github.graphql(
                    `mutation($projectId: ID!, $contentId: ID!) {
                      addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                        item { id }
                      }
                    }`,
                    { projectId: PMO_PROJECT_ID, contentId: issue.node_id }
                  );
                  const itemId = addRes.addProjectV2ItemById.item.id;

                  await github.graphql(
                    `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                      updateProjectV2ItemFieldValue(input: {
                        projectId: $projectId,
                        itemId: $itemId,
                        fieldId: $fieldId,
                        value: { singleSelectOptionId: $optionId }
                      }) { item { id } }
                    }`,
                    {
                      projectId: PMO_PROJECT_ID,
                      itemId,
                      fieldId: process.env.PMO_STATUS_FIELD_ID,
                      optionId: process.env.PMO_TRIAGE_OPTION_ID,
                    }
                  );
                  console.log(`Issue #${issue.number} routed to PMO project.`);
                } catch (e) {
                  console.log(`Error routing issue #${issue.number} to PMO: ${e.message}`);
                }
              } else if (hasSquad && !hasEpic) {
                await removeFromProject(PMO_PROJECT_ID, issue.node_id);
              }
            }
