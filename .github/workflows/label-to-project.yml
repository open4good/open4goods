name: Assign Issues to GitHub Projects V2 (bi-directional sync)

on:
  issues:
    types: [opened, labeled, unlabeled]
  workflow_dispatch:

env:
  ORG_NAME: open4good
  PROJECT_ID_MAPPING: |
    squad:pmo=PVT_kwDOBOJOp84A8tDc
    EPIC=PVT_kwDOBOJOp84A8tDc
    RISKY=PVT_kwDOBOJOp84A8tDc
    squad:ux=PVT_kwDOBOJOp84A2ZQ8
    squad:backend=PVT_kwDOBOJOp84A2ZRZ
    squad:exposition=PVT_kwDOBOJOp84A83dE
  PMO_PROJECT_ID: PVT_kwDOBOJOp84A8tDc
  PMO_STATUS_FIELD_ID: ${{ secrets.PMO_STATUS_FIELD_ID }}
  PMO_TRIAGE_OPTION_ID: ${{ secrets.PMO_TRIAGE_OPTION_ID }}

jobs:
  assign-on-event:
    if: github.event_name == 'issues'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          script: |
            const mapping = Object.fromEntries(
              process.env.PROJECT_ID_MAPPING
                .trim()
                .split('\n')
                .map(line => line.trim().split('='))
            );

            const issue = context.payload.issue;
            const labels = issue.labels.map(l => l.name);
            const hasSquad = labels.some(n => n.startsWith('squad:'));
            const hasEpic = labels.includes('EPIC');
            const noLabels = labels.length === 0;
            const shouldBeInPMO = noLabels || !hasSquad || hasEpic;

            async function getItemIdsByProject(contentId) {
              const res = await github.graphql(
                `query($contentId: ID!) {
                  node(id: $contentId) {
                    ... on Issue {
                      projectItems(first: 100) {
                        nodes {
                          id
                          project { id }
                        }
                      }
                    }
                  }
                }`,
                { contentId }
              );
              const out = {};
              for (const n of res.node.projectItems.nodes) out[n.project.id] = n.id;
              return out;
            }

            async function addToProject(projectId, contentId) {
              try {
                const addRes = await github.graphql(
                  `mutation($projectId: ID!, $contentId: ID!) {
                    addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                      item { id }
                    }
                  }`,
                  { projectId, contentId }
                );
                console.log(\`Added issue #${issue.number} to project ${projectId}\`);
                return addRes.addProjectV2ItemById.item.id;
              } catch (e) {
                console.log(\`Add failed for project ${projectId}: ${e.message}\`);
                return null;
              }
            }

            async function deleteFromProject(projectId, itemId) {
              try {
                await github.graphql(
                  `mutation($projectId: ID!, $itemId: ID!) {
                    deleteProjectV2Item(input: { projectId: $projectId, itemId: $itemId }) {
                      deletedItemId
                    }
                  }`,
                  { projectId, itemId }
                );
                console.log(\`Removed item ${itemId} from project ${projectId}\`);
              } catch (e) {
                console.log(\`Remove failed for project ${projectId}: ${e.message}\`);
              }
            }

            async function setPMOTriage(projectId, itemId) {
              if (!itemId) return;
              try {
                await github.graphql(
                  `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId,
                      value: { singleSelectOptionId: $optionId }
                    }) {
                      item { id }
                    }
                  }`,
                  {
                    projectId,
                    itemId,
                    fieldId: process.env.PMO_STATUS_FIELD_ID,
                    optionId: process.env.PMO_TRIAGE_OPTION_ID,
                  }
                );
                console.log(\`Set TRIAGE on PMO for issue #${issue.number}\`);
              } catch (e) {
                console.log(\`PMO status update failed: ${e.message}\`);
              }
            }

            const itemIdsByProject = await getItemIdsByProject(issue.node_id);

            // Sync for each mapped label/project
            for (const [label, projectId] of Object.entries(mapping)) {
              const hasLabel = labels.includes(label);
              const itemId = itemIdsByProject[projectId];

              if (hasLabel && !itemId) {
                const newId = await addToProject(projectId, issue.node_id);
                if (projectId === process.env.PMO_PROJECT_ID) {
                  await setPMOTriage(projectId, newId);
                }
              } else if (!hasLabel && itemId) {
                await deleteFromProject(projectId, itemId);
              }
            }

            // Explicit PMO fallback sync
            const pmoProjectId = process.env.PMO_PROJECT_ID;
            const pmoItemId = itemIdsByProject[pmoProjectId];

            if (shouldBeInPMO && !pmoItemId) {
              const newId = await addToProject(pmoProjectId, issue.node_id);
              await setPMOTriage(pmoProjectId, newId);
            } else if (!shouldBeInPMO && pmoItemId) {
              await deleteFromProject(pmoProjectId, pmoItemId);
            }

            console.log(`Sync done for issue #${issue.number}`);

  bulk-assign-on-dispatch:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          script: |
            const mapping = Object.fromEntries(
              process.env.PROJECT_ID_MAPPING
                .trim()
                .split('\n')
                .map(line => line.trim().split('='))
            );

            async function getItemIdsByProject(contentId) {
              const res = await github.graphql(
                `query($contentId: ID!) {
                  node(id: $contentId) {
                    ... on Issue {
                      projectItems(first: 100) {
                        nodes {
                          id
                          project { id }
                        }
                      }
                    }
                  }
                }`,
                { contentId }
              );
              const out = {};
              for (const n of res.node.projectItems.nodes) out[n.project.id] = n.id;
              return out;
            }

            async function addToProject(projectId, contentId) {
              try {
                const addRes = await github.graphql(
                  `mutation($projectId: ID!, $contentId: ID!) {
                    addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                      item { id }
                    }
                  }`,
                  { projectId, contentId }
                );
                return addRes.addProjectV2ItemById.item.id;
              } catch (e) {
                console.log(\`Add failed for project ${projectId}: ${e.message}\`);
                return null;
              }
            }

            async function deleteFromProject(projectId, itemId) {
              try {
                await github.graphql(
                  `mutation($projectId: ID!, $itemId: ID!) {
                    deleteProjectV2Item(input: { projectId: $projectId, itemId: $itemId }) {
                      deletedItemId
                    }
                  }`,
                  { projectId, itemId }
                );
              } catch (e) {
                console.log(\`Remove failed for project ${projectId}: ${e.message}\`);
              }
            }

            async function setPMOTriage(projectId, itemId) {
              if (!itemId) return;
              try {
                await github.graphql(
                  `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId,
                      value: { singleSelectOptionId: $optionId }
                    }) {
                      item { id }
                    }
                  }`,
                  {
                    projectId,
                    itemId,
                    fieldId: process.env.PMO_STATUS_FIELD_ID,
                    optionId: process.env.PMO_TRIAGE_OPTION_ID,
                  }
                );
              } catch (e) {
                console.log(\`PMO status update failed: ${e.message}\`);
              }
            }

            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100,
              }
            );

            for (const issue of issues) {
              if (issue.pull_request) continue;

              const labels = issue.labels.map(l => l.name);
              const hasSquad = labels.some(n => n.startsWith('squad:'));
              const hasEpic = labels.includes('EPIC');
              const noLabels = labels.length === 0;
              const shouldBeInPMO = noLabels || !hasSquad || hasEpic;

              const itemIdsByProject = await getItemIdsByProject(issue.node_id);

              // Sync per mapping
              for (const [label, projectId] of Object.entries(mapping)) {
                const hasLabel = labels.includes(label);
                const itemId = itemIdsByProject[projectId];

                if (hasLabel && !itemId) {
                  const newId = await addToProject(projectId, issue.node_id);
                  if (projectId === process.env.PMO_PROJECT_ID) {
                    await setPMOTriage(projectId, newId);
                  }
                } else if (!hasLabel && itemId) {
                  await deleteFromProject(projectId, itemId);
                }
              }

              // PMO fallback sync
              const pmoProjectId = process.env.PMO_PROJECT_ID;
              const pmoItemId = itemIdsByProject[pmoProjectId];

              if (shouldBeInPMO && !pmoItemId) {
                const newId = await addToProject(pmoProjectId, issue.node_id);
                await setPMOTriage(pmoProjectId, newId);
              } else if (!shouldBeInPMO && pmoItemId) {
                await deleteFromProject(pmoProjectId, pmoItemId);
              }

              console.log(`Synced issue #${issue.number}`);
            }
