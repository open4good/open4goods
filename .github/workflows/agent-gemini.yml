name: ðŸ¤– Gemini Agent (labels + comments)

on:
  issues:
    types: [labeled]
  pull_request:
    types: [labeled]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      target_number:
        description: "NumÃ©ro d'Issue/PR"
        required: true
        type: string
      force_state:
        description: "Force le state (created|interacting|blocked|done) - optionnel"
        required: false
        default: ""
        type: string
      model:
        description: "Override model (optionnel)"
        required: false
        default: ""
        type: string
      effort:
        description: "Override effort (low|medium|high) (optionnel)"
        required: false
        default: ""
        type: string

permissions:
  contents: read
  issues: write
  pull-requests: write

concurrency:
  group: gemini-agent-${{ github.repository }}-${{ github.event.issue.number || github.event.pull_request.number || inputs.target_number }}
  cancel-in-progress: false

jobs:
  gemini-agent:
    # Only run if 'gemini' label is present on issue/PR (case-insensitive), or if manually triggered
    if: >-
      ${{ github.actor != 'github-actions[bot]' && (
           github.event_name == 'workflow_dispatch' || (
             (github.event.issue && contains(join(github.event.issue.labels.*.name, ' '), 'gemini')) ||
             (github.event.pull_request && contains(join(github.event.pull_request.labels.*.name, ' '), 'gemini'))
           )
         ) }}
    runs-on:
      - self-hosted
      - agent:dev # Requires runner with 'agent:dev' label (adjust as needed)

    steps:
      - name: Checkout (default branch or PR merge ref)
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.pull_request.number && format('refs/pull/{0}/merge', github.event.pull_request.number) || github.event.repository.default_branch }}
          fetch-depth: 0

      - name: Resolve context + build prompt/schema
        id: prep
        uses: actions/github-script@v8
        with:
          github-token: ${{ github.token }}
          script: |
            const fs = require("fs");

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // ---------- Load config ----------
            const cfgPath = ".github/codex/agent.config.json";
            const cfg = JSON.parse(fs.readFileSync(cfgPath, "utf8"));

            const L = cfg.labels || {};
            const createdLabel = (L.created || "agent.created").toLowerCase();
            const interactingLabel = (L.interacting || "agent.interacting").toLowerCase();
            const iteractingAlias = (L.iteracting_alias || "agent.iteracting").toLowerCase();
            const workingLabel = (L.working || "agent.working");
            const blockedLabel = (L.blocked || "agent.blocked").toLowerCase();
            const doneLabel = (L.done || "agent.done").toLowerCase();

            // ---------- Resolve target number ----------
            let number;
            if (context.eventName === "workflow_dispatch") {
              number = Number(core.getInput("target_number", { required: true }));
            } else if (context.payload.issue?.number) {
              number = context.payload.issue.number;
            } else if (context.payload.pull_request?.number) {
              number = context.payload.pull_request.number;
            } else {
              throw new Error("Cannot resolve Issue/PR number");
            }

            // ---------- Stop on bot comments to avoid loops ----------
            const commentAuthor = context.payload.comment?.user?.login || "";
            if (context.eventName === "issue_comment") {
              const isBot = commentAuthor.endsWith("[bot]") || commentAuthor === "github-actions";
              if (isBot) {
                core.setOutput("should_run", "false");
                core.setOutput("reason", `Ignoring bot comment from ${commentAuthor}`);
                return;
              }
            }

            // ---------- Fetch issue (covers PR too) ----------
            const issue = (await github.rest.issues.get({ owner, repo, issue_number: number })).data;
            const labels = (issue.labels || [])
              .map(l => (typeof l === "string" ? l : l.name))
              .filter(Boolean);

            const labelSet = new Set(labels.map(s => String(s).toLowerCase()));

            // Ignore if done label present
            const ignoreWhen = new Set((cfg.behavior?.ignore_when_has_any_labels || []).map(s => String(s).toLowerCase()));
            for (const x of ignoreWhen) {
              if (labelSet.has(x)) {
                core.setOutput("should_run", "false");
                core.setOutput("reason", `Ignored because label present: ${x}`);
                return;
              }
            }

            // ---------- Determine trigger state ----------
            const forced = (core.getInput("force_state") || "").trim().toLowerCase();
            let triggerState = forced || "";

            const eventLabel = String(context.payload.label?.name || "").toLowerCase();

            const respondLabels = new Set((cfg.behavior?.respond_on_comment_when_has_any_labels || []).map(s => String(s).toLowerCase()));
            const hasRespondLabel = [...respondLabels].some(l => labelSet.has(l));

            if (!triggerState) {
              if (context.eventName === "issues" || context.eventName === "pull_request") {
                if (eventLabel === createdLabel) triggerState = "created";
                else if (eventLabel === interactingLabel || eventLabel === iteractingAlias) triggerState = "interacting";
              } else if (context.eventName === "issue_comment") {
                // Respond to EVERY new comment when interacting/blocked label is present
                if (hasRespondLabel) {
                  triggerState = labelSet.has(blockedLabel) ? "blocked" : "interacting";
                }
              }
            }

            if (!triggerState) {
              core.setOutput("should_run", "false");
              core.setOutput("reason", "No matching trigger");
              return;
            }

            // ---------- PR metadata if PR ----------
            const isPr = !!issue.pull_request;
            let pr = null;
            if (isPr) {
              pr = (await github.rest.pulls.get({ owner, repo, pull_number: number })).data;
            }

            // ---------- Load prompt template file ----------
            const stateCfg = (cfg.states || {})[triggerState];
            if (!stateCfg?.prompt_file) throw new Error(`No prompt_file for state '${triggerState}' in config`);
            const promptTpl = fs.readFileSync(stateCfg.prompt_file, "utf8");

            // ---------- Fetch recent comments ----------
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner, repo, issue_number: number, per_page: 100,
            });
            const MAX_COMMENTS = 30;
            const recent = comments.slice(-MAX_COMMENTS).map(c => ({
              author: c.user?.login || "unknown",
              created_at: c.created_at,
              body: (c.body || "").slice(0, 4000),
            }));

            // ---------- Compose context block ----------
            const commentBody = context.payload.comment?.body || "";
            const contextBlockParts = [
              `Repo: ${owner}/${repo}`,
              `Issue/PR #: ${number}`,
              `Title: ${issue.title || ""}`,
              `Labels: ${(labels || []).join(", ") || "(none)"}`,
              `Body:\n---\n${(issue.body || "").slice(0, 8000)}\n---`,
            ];

            if (isPr && pr) {
              contextBlockParts.push(`PR base: ${pr.base.ref} @ ${pr.base.sha}`);
              contextBlockParts.push(`PR head: ${pr.head.ref} @ ${pr.head.sha}`);
              contextBlockParts.push(`Helpful commands:\n- git log --oneline ${pr.base.sha}...${pr.head.sha}\n- git diff ${pr.base.sha}...${pr.head.sha}`);
              core.setOutput("base_ref", pr.base.ref);
              core.setOutput("base_sha", pr.base.sha);
              core.setOutput("head_sha", pr.head.sha);
              core.setOutput("pr_number", String(pr.number));
            } else {
              core.setOutput("base_ref", "");
              core.setOutput("base_sha", "");
              core.setOutput("head_sha", "");
              core.setOutput("pr_number", "");
            }

            if (commentBody) {
              contextBlockParts.push(`Last comment:\n---\n${commentBody}\n---`);
            }
            contextBlockParts.push(`Recent comments (max ${MAX_COMMENTS}):`);
            for (const c of recent) {
              contextBlockParts.push(`- ${c.author} @ ${c.created_at}:\n${c.body}\n`);
            }

            const contextBlock = contextBlockParts.join("\n\n");

            // ---------- Output schema expected from Codex ----------
            const schema = {
              type: "object",
              additionalProperties: false,
              properties: {
                next_state: { type: "string", enum: ["interacting", "blocked", "done"] },
                reply_markdown: { type: "string" },
                labels_add: { type: "array", items: { type: "string" } },
                labels_remove: { type: "array", items: { type: "string" } }
              },
              required: ["next_state", "reply_markdown", "labels_add", "labels_remove"]
            };

            // ---------- Final prompt ----------
            const finalPrompt = [
              promptTpl.trim(),
              "",
              "IMPORTANT: RÃ©ponds UNIQUEMENT avec du JSON conforme au schema fourni.",
              "",
              "Schema JSON attendu:",
              "```json",
              JSON.stringify(schema, null, 2),
              "```",
              "",
              "Contexte:",
              "```",
              contextBlock,
              "```"
            ].join("\n");

            fs.mkdirSync(".codex", { recursive: true });
            fs.writeFileSync(".codex/prompt.md", finalPrompt, "utf8");
            fs.writeFileSync(".codex/schema.json", JSON.stringify(schema, null, 2), "utf8");

            // ---------- Codex params (config + overrides) ----------
            const cfgCodex = cfg.codex || {};
            const inModel = (core.getInput("model") || "").trim();
            const inEffort = (core.getInput("effort") || "").trim();

            const model = inModel || (cfgCodex.model || "");
            const effort = inEffort || (cfgCodex.effort || "");
            const sandbox = (cfgCodex.sandbox || "read-only");
            const safetyStrategy = (cfgCodex.safety_strategy || "drop-sudo");
            const codexArgs = (cfgCodex.codex_args || "");

            // Provide prompt content for Gemini CLI
            core.setOutput("prompt_content", finalPrompt);
            core.setOutput("should_run", "true");
            core.setOutput("number", String(number));
            core.setOutput("trigger_state", triggerState);
            core.setOutput("is_pr", String(isPr));
            core.setOutput("prompt_file", ".codex/prompt.md");
            core.setOutput("schema_file", ".codex/schema.json");
            core.setOutput("model", model);
            core.setOutput("effort", effort);
            core.setOutput("sandbox", sandbox);
            core.setOutput("safety_strategy", safetyStrategy);
            core.setOutput("codex_args", codexArgs);
            core.setOutput("working_label", workingLabel);

      - name: Exit if nothing to do
        if: steps.prep.outputs.should_run != 'true'
        run: echo "${{ steps.prep.outputs.reason }}"

      - name: Pre-fetch base and head refs (PR only)
        if: steps.prep.outputs.should_run == 'true' && steps.prep.outputs.pr_number != ''
        run: |
          git fetch --no-tags origin \
            "${{ steps.prep.outputs.base_ref }}" \
            "+refs/pull/${{ steps.prep.outputs.pr_number }}/head"

      - name: Mark agent as working (label)
        if: steps.prep.outputs.should_run == 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner, repo = context.repo.repo;
            const issue_number = Number("${{ steps.prep.outputs.number }}");
            const label = "${{ steps.prep.outputs.working_label }}";
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number, labels: [label] });
            } catch (e) {
              core.info(`Could not add ${label}: ${e.message}`);
            }

      - name: Run Gemini CLI
        if: steps.prep.outputs.should_run == 'true'
        id: run_gemini
        uses: google-github-actions/run-gemini-cli@v0
        env:
          GITHUB_TOKEN: "" # Do not pass token to Gemini CLI (untrusted input)
        with:
          gemini_api_key: ${{ secrets.GEMINI_KEY }} # Use Gemini API key
          gemini_model: ${{ steps.prep.outputs.model }} # Preserve model override if set
          prompt: ${{ steps.prep.outputs.prompt_content }} # Use prepared prompt with JSON schema
          settings: |-
            {
              "coreTools": [ "run_shell_command(echo)" ]
            }  # Restrict Gemini CLI to safe shell commands only

      - name: Apply result (comments + labels)
        if: steps.prep.outputs.should_run == 'true'
        uses: actions/github-script@v8
        env:
          CODEX_JSON: ${{ steps.run_gemini.outputs.summary }} # Use Gemini CLI output
        with:
          github-token: ${{ github.token }}
          script: |
            const fs = require("fs");

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = Number("${{ steps.prep.outputs.number }}");

            const cfg = JSON.parse(fs.readFileSync(".github/codex/agent.config.json", "utf8"));

            // Updated default comment marker and title for Gemini
            const marker = cfg.thread_comment?.marker || "<!-- GEMINI_AGENT_THREAD v1 -->";
            const title = cfg.thread_comment?.title || "ðŸ¤– Gemini Agent";

            const L = cfg.labels || {};
            const stateLabels = cfg.state_labels || {};
            const policy = cfg.label_policy || {};

            const allStateLabels = new Set(Object.values(stateLabels).flat().map(s => String(s)));
            const working = String(L.working || "agent.working");

            // Parse Gemini output JSON (structured)
            let raw = process.env.CODEX_JSON || "";
            // Remove any Markdown code fences or JSON syntax hints
            raw = raw.replace(/^```(json)?\r?\n?/, "").replace(/\r?\n?```$/, "");
            let out;
            try {
              out = JSON.parse(raw.trim());
            } catch (e) {
              out = {
                next_state: "interacting",
                reply_markdown: raw || "Gemini output was not JSON.",
                labels_add: [],
                labels_remove: []
              };
            }

            const nextState = String(out.next_state || "interacting");
            const reply = String(out.reply_markdown || "").trim();

            const requestedAdd = Array.isArray(out.labels_add) ? out.labels_add.map(String) : [];
            const requestedRemove = Array.isArray(out.labels_remove) ? out.labels_remove.map(String) : [];

            // --- Label policy enforcement (business labels allowed) ---
            const isAgentLabel = (name) => String(name).toLowerCase().startsWith("agent.");
            const protectedExact = new Set((policy.protected_exact || []).map(s => String(s).toLowerCase()));
            const protectedPrefixes = (policy.protected_prefixes || []).map(s => String(s).toLowerCase());

            const isProtected = (name) => {
              const n = String(name).toLowerCase();
              if (protectedExact.has(n)) return true;
              return protectedPrefixes.some(p => n.startsWith(p));
            };

            const allowAnyAdd = !!policy.allow_any_non_agent_add;
            const allowAnyRemove = !!policy.allow_any_non_agent_remove;

            const filterAdd = (name) => {
              if (!name) return false;
              const n = String(name).trim();
              if (!n) return false;
              if (isProtected(n)) return false;
              if (isAgentLabel(n)) return true;
              return allowAnyAdd;
            };

            const filterRemove = (name) => {
              if (!name) return false;
              const n = String(name).trim();
              if (!n) return false;
              if (isProtected(n)) return false;
              if (isAgentLabel(n)) return true;
              return allowAnyRemove;
            };

            const extraAdd = requestedAdd.filter(filterAdd);
            const extraRemove = requestedRemove.filter(filterRemove);

            // Compose thread comment body
            const now = new Date().toISOString();
            const threadBody = [
              marker,
              `## ${title}`,
              ``,
              `**State:** \`${nextState}\``,
              `**Last update:** ${now}`,
              ``,
              reply
            ].join("\n");

            // Find existing thread comment
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner, repo, issue_number, per_page: 100
            });
            const existing = [...comments].reverse().find(c => (c.body || "").includes(marker));

            const updateThread = !!cfg.behavior?.update_single_thread_comment;
            const postOnComment = !!cfg.behavior?.post_reply_on_comment_event;
            const postOnLabel = !!cfg.behavior?.post_reply_on_label_event;

            const isCommentEvent = context.eventName === "issue_comment";
            const shouldPostReply = (isCommentEvent && postOnComment) || (!isCommentEvent && postOnLabel);

            if (updateThread) {
              if (existing) {
                await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body: threadBody });
              } else {
                await github.rest.issues.createComment({ owner, repo, issue_number, body: threadBody });
              }
            }

            if (shouldPostReply) {
              await github.rest.issues.createComment({
                owner, repo, issue_number,
                body: reply || "(empty reply)"
              });
            }

            // Labels: remove all agent state labels + agent.working, then add labels for next state + extras
            // This guarantees: when next_state=done, agent.interacting is removed systematically.
            const toRemove = new Set([...allStateLabels, working, ...extraRemove]);
            for (const name of toRemove) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number, name });
              } catch (_) {}
            }

            const nextLabels = (stateLabels[nextState] || []);
            const toAdd = new Set([...nextLabels, ...extraAdd]);

            if (toAdd.size) {
              try {
                await github.rest.issues.addLabels({ owner, repo, issue_number, labels: [...toAdd] });
              } catch (e) {
                core.info(`AddLabels failed (missing labels?): ${e.message}`);
              }
            }
