name: Assign PRs to GitHub Projects V2

on:
  pull_request:
    types:
      - opened
      - reopened
      - labeled
      - unlabeled
      - synchronize
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Ne rien modifier, seulement logguer"
        required: false
        type: boolean
        default: false

env:
  # mapping label → ProjectV2 ID
  PROJECT_ID_MAPPING: |
    squad:pmo=PVT_kwDOBOJOp84A8tDc
    squad:ux=PVT_kwDOBOJOp84A2ZQ8
    squad:backend=PVT_kwDOBOJOp84A2ZRZ
  # projet fallback si aucun label ne matche
  IF_UNMATCH: PVT_kwDOBOJOp84A8tDc
  # ne traiter que les PR dont l’auteur est ce bot
  FILTER_AUTHOR: renovate[bot]

jobs:
  assign:
    runs-on: ubuntu-latest
    steps:
      - name: Assign PR to Projects
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          script: |
            // --- Helpers ---
            function parseMapping(raw) {
              return Object.fromEntries(
                raw
                  .trim()
                  .split('\n')
                  .map(l => l.trim().split('='))
                  .map(([k,v]) => [k.toLowerCase(), v.trim()])
                  .filter(([k,v]) => k && v)
              );
            }

            async function assertProjectsExist(ids) {
              const unique = [...new Set(ids.filter(Boolean))];
              if (!unique.length) return;
              const query = `
                query($ids: [ID!]!) {
                  nodes(ids: $ids) {
                    __typename
                    ... on ProjectV2 { id title }
                  }
                }
              `;
              const res = await github.graphql(query, { ids: unique });
              const missing = unique.filter((id, i) => {
                const node = res.nodes[i];
                return !node || node.__typename !== 'ProjectV2';
              });
              if (missing.length) {
                core.setFailed(\`Project IDs introuvables: \${missing.join(', ')}\`);
                throw new Error('Unknown project ids');
              }
            }

            async function getPRProjectItems(prNodeId) {
              const q = `
                query($id: ID!) {
                  node(id: $id) {
                    ... on PullRequest {
                      projectItems(first: 100) {
                        nodes {
                          id
                          project { id }
                        }
                      }
                    }
                  }
                }
              `;
              const r = await github.graphql(q, { id: prNodeId });
              return r.node.projectItems.nodes.map(n => ({
                itemId:    n.id,
                projectId: n.project.id
              }));
            }

            async function addPRToProject(contentId, projectId) {
              const m = `
                mutation($projectId: ID!, $contentId: ID!) {
                  addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                    item { id }
                  }
                }
              `;
              return github.graphql(m, { projectId, contentId });
            }

            async function removeItem(itemId, projectId) {
              const m = `
                mutation($projectId: ID!, $itemId: ID!) {
                  deleteProjectV2Item(input: { projectId: $projectId, itemId: $itemId }) {
                    deletedItemId
                  }
                }
              `;
              return github.graphql(m, { projectId, itemId });
            }

            function desiredProjects(labels, mapping, fallback) {
              const set = new Set();
              labels.forEach(l => {
                if (mapping[l]) set.add(mapping[l]);
              });
              if (set.size === 0 && fallback) set.add(fallback);
              return [...set];
            }

            async function processOnePR(prNumber, dryRun) {
              const { owner, repo } = context.repo;
              const pr = (await github.rest.pulls.get({ owner, repo, pull_number: prNumber })).data;

              if (filterAuth && pr.user.login !== filterAuth) {
                core.info(\`ℹ️ PR #\${prNumber} auteur '\${pr.user.login}' ignoré.\`);
                return;
              }

              const labels = pr.labels.map(l => l.name.toLowerCase());
              core.info(\`🔖 PR #\${prNumber} labels: \${labels.join(', ') || '(aucun)'}\`);

              const desired   = desiredProjects(labels, mapping, fallback);
              const existing  = await getPRProjectItems(pr.node_id);
              const existIds  = existing.map(x => x.projectId);

              const toAdd    = desired.filter(id => !existIds.includes(id));
              const toRemove = existing.filter(x => !desired.includes(x.projectId));

              core.info(\`➕ À ajouter: \${toAdd.join(', ') || '(aucun)'}\`);
              core.info(\`🗑️ À supprimer: \${toRemove.map(x => x.projectId).join(', ') || '(aucun)'}\`);

              if (dryRun) {
                core.info('🔍 [DRY RUN] Aucun changement appliqué.');
                return;
              }

              for (const proj of toAdd) {
                await addPRToProject(pr.node_id, proj)
                  .then(() => core.info(\`✅ Ajouté à \${proj}\`))
                  .catch(e => core.setFailed(\`❌ Échec ajout \${proj}: \${e.message}\`));
              }
              for (const { itemId, projectId } of toRemove) {
                await removeItem(itemId, projectId)
                  .then(() => core.info(\`🗑️ Supprimé de \${projectId}\`))
                  .catch(e => core.setFailed(\`❌ Échec suppression \${projectId}: \${e.message}\`));
              }
            }

            // ==== Main ====
            const mapping    = parseMapping(process.env.PROJECT_ID_MAPPING || '');
            const fallback   = (process.env.IF_UNMATCH || '').trim();
            const filterAuth = (process.env.FILTER_AUTHOR || '').trim();
            const dryRun     = core.getInput('dry_run') === 'true';

            await assertProjectsExist(Object.values(mapping).concat(fallback));

            // Déterminer la liste des PR à traiter
            let prNumbers = [];
            if (context.eventName === 'workflow_dispatch') {
              const { owner, repo } = context.repo;
              let page = 1;
              while (true) {
                const res = await github.rest.pulls.list({
                  owner, repo, state: 'open', per_page: 100, page
                });
                if (res.data.length === 0) break;
                res.data.forEach(pr => prNumbers.push(pr.number));
                page++;
              }
            } else {
              prNumbers = [ context.payload.pull_request.number ];
            }

            core.startGroup(\`Processing \${prNumbers.length} PR(s)\`);
            for (const num of prNumbers) {
              await processOnePR(num, dryRun);
            }
            core.endGroup();
            core.info('🎉 Terminé.');
