## Déploiement opérationnel sur GitHub Projects

### Choix méthodologique : Kanban

Pour la gestion opérationnelle, Nudger adopte une approche **Kanban agile** souple, en s’appuyant sur GitHub Projects pour le suivi des tâches. Ce choix méthodologique privilégie un flux continu d’intégration des évolutions, ce qui convient bien à une équipe héterogene où la disponibilité peut varier – on évite ainsi la rigidité de sprints fixes une fois le produit lancé. **L’intelligence artificielle** est mise à contribution pour assister ce Kanban : Nudger étant un projet techniquement innovant (intégrant de l’IA générative côté produit), l’équipe exploite également des outils basés sur l’IA pour optimiser sa gestion. Concrètement, cela signifie utiliser des assistants comme GitHub Copilot ou OpenAI Codex pour aider à la planification et au développement (rédaction de tâches, aide à l’estimation, voire automatisation de certaines opérations de routine).

Cependant, pour le **lancement initial (première release majeure)**, l’équipe convient de fonctionner par **sprints délimités**. En effet, avant d’atteindre la v1.0, un cap a été fixé avec des objectifs à court terme et une date cible de sortie. Ce cadre de sprint sur quelques semaines permet de conserver un focus et une pression positive pour livrer les fonctionnalités essentielles du pproduit. Pendant cette phase, on emprunte donc au Scrum en définissant un backlog de sprint, des priorités serrées et un suivi rapproché de l’avancement (par exemple via un burn-down chart). Une fois la première version majeure livrée, Nudger basculera sur un mode plus itératif en flux continu : les nouvelles features et correctifs seront intégrés dès qu’ils sont prêts, en repartant sur un **Kanban pur** (sans échéances de sprint imposées, sauf pour des jalons stratégiques ponctuels).

### Organisation du board GitHub Projects : colonnes et automatisations

Le tableau de bord de projet (*Project*) sur GitHub sera configuré selon un **flux Kanban standard**, avec les colonnes suivantes :

- **Triage** – Réception des tickets entrants. C’est la colonne d’arrivée par défaut de toute nouvelle issue ouverte (que ce soit un bug report ou une idée d’évolution). Un workflow d’automatisation permettra d’ajouter automatiquement les nouvelles issues dans *Triage* pour ne rien manquer. L’objectif est que l’équipe passe en revue cette colonne régulièrement. Chaque élément en Triage sera évalué puis soit fermé (si invalide ou dupliqué), soit étiqueté et déplacé en Backlog s’il est approuvé.
- **Backlog** – Regroupe toutes les tâches **validées et priorisées** en attente de traitement. Cette colonne est triée par ordre de priorité (les items les plus importants/urgents en haut). Elle constitue le réservoir dans lequel les développeurs piochent lorsqu’ils sont disponibles pour entamer quelque chose de nouveau. Seules les issues clairement définies et acceptées par l’équipe arrivent dans le Backlog (via la triage).
- **In Progress** – Représente les tâches **en cours de traitement**. Dès qu’un développeur commence à travailler sur une issue, celle-ci est déplacée en “In Progress”. Une automatisation GitHub Projects pourra effectuer ce déplacement de colonne dès qu’une issue se voit assignée à quelqu’un ou liée à une Pull Request ouverte (ce qui indique qu’on a entamé le développement).
- **Review** – Cette colonne contient les travaux en cours de revue ou de recette. Concrètement, lorsqu’une Pull Request est soumise pour résoudre une issue (ou qu’un développement est terminé en attente de validation), l’élément passe en **Review**. Une règle d’automatisation typique est de déplacer automatiquement une carte en Review dès qu’une Pull Request liée est ouverte (ou marquée “Ready for review”). Les code reviews sont alors effectuées par les pairs (idéalement par un autre membre engagé), et les tests qualité sont réalisés.
- **Done** – Rassemble les éléments **terminés** et fermés. Lorsqu’une Pull Request est mergée et que l’issue correspondante se ferme (via les mots-clés *Closes #num* dans la PR), la carte est automatiquement déplacée en Done. On peut configurer un déclencheur de type “quand une issue est fermée ou qu’une PR est mergée” pour alimenter cette colonne. Les éléments en Done peuvent rester visibles jusqu’à la fin de la semaine (pour le suivi du sprint hebdo, ou la préparation des KPIs), puis ils sont archivés du board afin de garder ce dernier lisible.

Chaque colonne du Kanban est ainsi associée à des **règles d’automatisation** afin de minimiser les manipulations manuelles et fiabiliser le flux de travail. Par exemple, on peut **automatiser le passage en In Progress** dès qu’une issue est assignée ou qu’une PR est liée, le passage en **Done dès qu’une issue est fermée**:contentReference[oaicite:11]{index=11}, etc. GitHub Projects (Beta) permet de définir ce type de règles via l’interface du projet ou via des Actions. Le respect de conventions uniformes (comme l’utilisation systématique de mots-clés *Fixes/Closes* dans les descriptions de PR) garantit que la **fermeture des tickets** soit bien synchronisée avec le code mergé.

En complément, des GitHub Actions spécifiques pourront être utilisées pour gérer des cas plus avancés. Par exemple, une Action peut étiqueter et déplacer automatiquement une issue signalée par un utilisateur (via le feedback du site) dans *Triage* avec un label “community” et notifier l’équipe. Une autre pourrait rappeler via Slack/Mail les issues restées trop longtemps en Review (pour encourager les reviewers à finaliser). Globalement, ce **Kanban outillé** offre une visibilité en temps réel sur l’état du projet et permet de repérer rapidement les points de blocage (ex: une carte stagnante en Review signale peut-être un besoin d’aide sur la revue).

### Stratégie de labellisation pour la catégorisation des issues

Afin de faciliter le filtrage et le suivi des tickets, Nudger va mettre en place une **stratégie de labels** (aka : tags github issues)  couvrant plusieurs axes de catégorisation cohérents. Les principales catégories de labels envisagées incluent :

- **Composant/Module impacté :** pour indiquer la partie du système concernée par l’issue. Par exemple, `component:frontend` (pour les problèmes UI/UX ou site web), `component:backend` (moteur de recherche, API), `component:crawler`, `component:SEO`, etc. Ce découpage par composant permettra aux spécialistes de chaque domaine d’identifier rapidement les tickets pertinents pour eux.
- **Type de ticket :** pour distinguer la nature de l’issue. On utilisera des labels tels que `type:bug` (anomalie à corriger), `type:feature` (demande de nouvelle fonctionnalité), `type:enhancement` (amélioration mineure d’une fonction existante), `type:discussion` (nécessite une décision ou un design), `type:documentation` (mise à jour de doc ou README), etc. Ces étiquettes aident à filtrer (par exemple traiter d’abord les bugs critiques) et donnent un contexte dès la lecture du titre.
- **Priorité :** tous les tickets validés se verront attribuer un niveau de priorité. Une convention pourrait être d’utiliser des labels du style `priority:P0` (Urgent/Critique), `priority:P1` (Hautement prioritaire), `priority:P2` (Moyen), `priority:P3` (Faible). Ou de manière littérale : `priority:high/medium/low`. La priorité est décidée lors du triage et peut être ajustée en cours de route si le contexte change. Elle indique l’ordre de traitement recommandé au sein du backlog.
- **Statut/État complémentaire :** bien que le déplacement dans les colonnes du Kanban renseigne l’état principal (à faire, en cours, en revue, fait), on peut ajouter des labels pour des états transverses. Par exemple `status:blocked` (si une issue est bloquée par une dépendance externe ou une décision), `status:need specs` (si l’issue requiert encore des précisions avant dev), `status:duplicate` (si c’est un doublon d’une autre issue), ou `wontfix` le cas échéant. Ces labels servent surtout pendant le triage et la revue du backlog pour signaler des situations particulières.
- **Source de la demande :** afin de tracer l’origine d’une idée ou d’un bug, on peut taguer les issues avec `source:community` (retours utilisateurs via le site ou GitHub), `source:internal` (idée émanant de l’équipe interne), voire `source:partner` si une suggestion provient d’un partenaire ou d’un mentor. Ceci valorise l’apport de la communauté et peut influencer la priorisation (ex: une suggestion communauté aura tendance à être priorisée si elle recueille des votes).
- **Engagement / accessibilité de la tâche :** Nudger souhaite aussi indiquer quelles tâches sont **ouvertes aux contributeurs occasionnels ou learners**. On réutilisera pour cela les conventions GitHub existantes : par exemple le label `good first issue` sera apposé sur des tickets simples, bien cadrés, idéaux pour un nouveau contributeur (learner) souhaitant faire sa première PR. De même, un label `help wanted` peut signaler qu’une aide extérieure est la bienvenue sur un ticket (souvent utilisé quand l’équipe core manque de temps ou de compétences très pointues sur ce sujet). Ces labels “d’engagement” encouragent la communauté à mettre la main à la pâte en identifiant ce sur quoi elle peut intervenir facilement. À l’inverse, si certaines issues sont réservées à l’équipe core (soit pour des raisons de sécurité, soit parce qu’elles nécessitent une connaissance profonde du système), on évitera de leur mettre `help wanted` et on peut les marquer en interne d’un label du genre `core-only` (même si celui-ci ne sera pas mis en avant publiquement).

Chaque ticket se verra donc attribuer une **combinaison de labels** couvrant ces axes (ex: un bug critique sur le frontend demandé par un utilisateur aura `type:bug`, `component:frontend`, `priority:P0`, `source:community`). Une utilisation **cohérente des libellés** est importante : l’équipe définira une nomenclature claire et veillera à l’appliquer lors du triage. Cela permettra d’utiliser efficacement les filtres de GitHub (par exemple afficher toutes les features backend P1 en attente) et de générer des **vues personnalisées** dans GitHub Projects.

Le tag **votable** sera attribuée aux issues pour lequelle l'avis des utilisateurs est demandé. Toute issue nouvellement créés **depuis les sites utilisateurs** se verront affecter cette etiquette **votable**

### Vues GitHub Projects : publique vs interne

GitHub Projects (Beta) offre la possibilité de créer des **vues personnalisées** du board, ce que Nudger exploitera pour adresser différemment le public externe et l’équipe interne. Deux vues principales seront configurées :

- **Vue publique (backlog communautaire)** – Cette vue, rendue publique et facilement accessible (depuis le README ou le site Nudger via un lien), présentera aux utilisateurs la liste des idées et évolutions envisagées, avec la possibilité pour la communauté de **voter** et commenter.

Cette backlog sera un filtrepour ne restituer que les issues tagguées **visibility:public**. Un usage classique peut être d'avoir les issue "parent" en visibility::public, et les issues enfants en visibility:internal, permetant ainsi de garder un lien clair entre issues presentés au public et les taches de travail pilotés et utilisées par l'équipe interne.

Concrètement, cette vue affichera surtout les issues de type *feature requests* et suggestions ouvertes, probablement celles dans la colonne Backlog (ou une colonne dédiée aux idées proposées ?). On peut filtrer pour ne montrer que les items marqués `source:community` ou ayant un label particulier signifiant “Suggestion d’amélioration”.  Ces **votes utilisateurs** serviront de référence lors de la priorisation : un tri par nombre de 👍 (ou un champ custom “Votes”) permettra d’identifier les demandes les plus plébiscitées. La vue publique sera présentée de manière simple et transparente, sans informations techniques superflues – par exemple, on n’y affichera pas nécessairement les champs internes comme la complexité ou l’assignee. Le but est que les contributeurs non techniques et utilisateurs puissent **suivre l’avancement** du projet et se sentir impliqués dans les choix d’évolution. De même,

- **Vue interne (pilotage technique)** – A destination de la Tribe (mais pour autant publiquement exposée pour les curieux) , la vue interne offrira un **tableau de bord complet** pour le suivi au jour le jour. Elle inclura l’ensemble des colonnes (Triage, Backlog, In Progress, Review, Done) et toutes les issues, y compris les tâches purement techniques ou de maintenance que la communauté n’a pas forcément besoin de voir en priorité. Dans cette vue, on pourra afficher des champs supplémentaires comme l’**assignation** (qui travaille sur quoi), la **priorité interne** (parfois l’équipe peut ajuster l’ordre indépendamment des votes publics, par exemple pour corriger un bug critique ayant peu de votes car peu visible du public), ou encore un champ **échéance** si certaines tâches ont une deadline. La vue interne servira au **pilotage technique** lors des réunions d’équipe : on peut l’utiliser en partage d’écran durant le stand-up hebdo pour passer en revue chaque colonne. Elle permet également aux membres de savoir sur quoi travaillent leurs collègues en un coup d’œil et de détecter les surcharges (trop de cartes sur une personne, par exemple). Cette vue pourra être privée (accessible uniquement aux membres du repo) si l’équipe souhaite y mettre des commentaires ou champs confidentiels, mais comme le projet Nudger est public, même les aspects techniques pourraient en grande partie être ouverts. Quoi qu’il en soit, la séparation des vues garantit une **lisibilité adaptée à chaque audience** : le public voit l’état du produit et peut contribuer aux idées, l’équipe voit le détail opérationnel pour conduire le projet efficacement.

En somme, ces deux perspectives sur le même projet assurent la **transparence vis-à-vis des utilisateurs** tout en préservant un outil de travail complet et "end to end" pour l’équipe. Cette configuration est évolutive : Nudger pourra ajouter d’autres vues filtrées (par exemple une vue “Bugs only” pour se concentrer sur la qualité, ou une vue par composant pour les squads frontend/backend).

Les taches autres que techniques (communication, redactionnel, gestion de projet) seront également suivies de la même manière, afin d'offrir une vue complete et cohérente de l'integralité des tâches du projt Nudger

## Release

Les releases sont des marqueurs importants et de célebration. En mode déploiement continue sur la cible, il convient pour autant d'animer et suivre les releases.

Pour cela, on utilisera du Semver, on visera a trouver une thematique de noms "Tribe, Green ? TODO : Action equipe", et on generera automatiquement les releases notes, comprenant les tâches non techs. On visera si possible a animer ces releases de façon ouverte sur le blog et les réseaux

TODO : Expliquer
TODO : Les releases integrent aussi les taches non tech
TODO: Animation autour des Releases

> On gere les taches "projet / communication" egalement comme cela
PArler du cycle de Release
> 
