## DÃ©ploiement opÃ©rationnel sur GitHubÂ Projects

### Choix mÃ©thodologiqueÂ : Kanban

Pour la gestion opÃ©rationnelle, Nudger adopte une approche **Kanban agile** souple, en sâ€™appuyant sur GitHub Projects pour le suivi des tÃ¢ches. Ce choix mÃ©thodologique privilÃ©gie un flux continu dâ€™intÃ©gration des Ã©volutions, ce qui convient bien Ã  une Ã©quipe hÃ©terogene oÃ¹ la disponibilitÃ© peut varier â€“ on Ã©vite ainsi la rigiditÃ© de sprints fixes une fois le produit lancÃ©. **Lâ€™intelligence artificielle** est mise Ã  contribution pour assister ce KanbanÂ : Nudger Ã©tant un projet techniquement innovant (intÃ©grant de lâ€™IA gÃ©nÃ©rative cÃ´tÃ© produit), lâ€™Ã©quipe exploite Ã©galement des outils basÃ©s sur lâ€™IA pour optimiser sa gestion. ConcrÃ¨tement, cela signifie utiliser des assistants comme GitHub Copilot ou OpenAI Codex pour aider Ã  la planification et au dÃ©veloppement (rÃ©daction de tÃ¢ches, aide Ã  lâ€™estimation, voire automatisation de certaines opÃ©rations de routine).

Cependant, pour le **lancement initial (premiÃ¨re release majeure)**, lâ€™Ã©quipe convient de fonctionner par **sprints dÃ©limitÃ©s**. En effet, avant dâ€™atteindre la v1.0, un cap a Ã©tÃ© fixÃ© avec des objectifs Ã  court terme et une date cible de sortie. Ce cadre de sprint sur quelques semaines permet de conserver un focus et une pression positive pour livrer les fonctionnalitÃ©s essentielles du pproduit. Pendant cette phase, on emprunte donc au Scrum en dÃ©finissant un backlog de sprint, des prioritÃ©s serrÃ©es et un suivi rapprochÃ© de lâ€™avancement (par exemple via un burn-down chart). Une fois la premiÃ¨re version majeure livrÃ©e, Nudger basculera sur un mode plus itÃ©ratif en flux continuÂ : les nouvelles features et correctifs seront intÃ©grÃ©s dÃ¨s quâ€™ils sont prÃªts, en repartant sur un **Kanban pur** (sans Ã©chÃ©ances de sprint imposÃ©es, sauf pour des jalons stratÃ©giques ponctuels).

### Organisation du board GitHub ProjectsÂ : colonnes et automatisations

Le tableau de bord de projet (*Project*) sur GitHub sera configurÃ© selon un **flux Kanban standard**, avec les colonnes suivantesÂ :

- **Triage** â€“ RÃ©ception des tickets entrants. Câ€™est la colonne dâ€™arrivÃ©e par dÃ©faut de toute nouvelle issue ouverte (que ce soit un bug report ou une idÃ©e dâ€™Ã©volution). Un workflow dâ€™automatisation permettra dâ€™ajouter automatiquement les nouvelles issues dans *Triage* pour ne rien manquer. Lâ€™objectif est que lâ€™Ã©quipe passe en revue cette colonne rÃ©guliÃ¨rement. Chaque Ã©lÃ©ment en Triage sera Ã©valuÃ© puis soit fermÃ© (si invalide ou dupliquÃ©), soit Ã©tiquetÃ© et dÃ©placÃ© en Backlog sâ€™il est approuvÃ©.
- **Backlog** â€“ Regroupe toutes les tÃ¢ches **validÃ©es et priorisÃ©es** en attente de traitement. Cette colonne est triÃ©e par ordre de prioritÃ© (les items les plus importants/urgents en haut). Elle constitue le rÃ©servoir dans lequel les dÃ©veloppeurs piochent lorsquâ€™ils sont disponibles pour entamer quelque chose de nouveau. Seules les issues clairement dÃ©finies et acceptÃ©es par lâ€™Ã©quipe arrivent dans le Backlog (via la triage).
- **InÂ Progress** â€“ ReprÃ©sente les tÃ¢ches **en cours de traitement**. DÃ¨s quâ€™un dÃ©veloppeur commence Ã  travailler sur une issue, celle-ci est dÃ©placÃ©e en â€œIn Progressâ€. Une automatisation GitHub Projects pourra effectuer ce dÃ©placement de colonne dÃ¨s quâ€™une issue se voit assignÃ©e Ã  quelquâ€™un ou liÃ©e Ã  une Pull Request ouverte (ce qui indique quâ€™on a entamÃ© le dÃ©veloppement).
- **Review** â€“ Cette colonne contient les travaux en cours de revue ou de recette. ConcrÃ¨tement, lorsquâ€™une Pull Request est soumise pour rÃ©soudre une issue (ou quâ€™un dÃ©veloppement est terminÃ© en attente de validation), lâ€™Ã©lÃ©ment passe en **Review**. Une rÃ¨gle dâ€™automatisation typique est de dÃ©placer automatiquement une carte en Review dÃ¨s quâ€™une Pull Request liÃ©e est ouverte (ou marquÃ©e â€œReady for reviewâ€). Les code reviews sont alors effectuÃ©es par les pairs (idÃ©alement par un autre membre engagÃ©), et les tests qualitÃ© sont rÃ©alisÃ©s.
- **Done** â€“ Rassemble les Ã©lÃ©ments **terminÃ©s** et fermÃ©s. Lorsquâ€™une Pull Request est mergÃ©e et que lâ€™issue correspondante se ferme (via les mots-clÃ©s *Closes #num* dans la PR), la carte est automatiquement dÃ©placÃ©e en Done. On peut configurer un dÃ©clencheur de type â€œquand une issue est fermÃ©e ou quâ€™une PR est mergÃ©eâ€ pour alimenter cette colonne. Les Ã©lÃ©ments en Done peuvent rester visibles jusquâ€™Ã  la fin de la semaine (pour le suivi du sprint hebdo, ou la prÃ©paration des KPIs), puis ils sont archivÃ©s du board afin de garder ce dernier lisible.

Chaque colonne du Kanban est ainsi associÃ©e Ã  des **rÃ¨gles dâ€™automatisation** afin de minimiser les manipulations manuelles et fiabiliser le flux de travail. Par exemple, on peut **automatiser le passage en In Progress** dÃ¨s quâ€™une issue est assignÃ©e ou quâ€™une PR est liÃ©e, le passage en **Done dÃ¨s quâ€™une issue est fermÃ©e**:contentReference[oaicite:11]{index=11}, etc. GitHub Projects (Beta) permet de dÃ©finir ce type de rÃ¨gles via lâ€™interface du projet ou via des Actions. Le respect de conventions uniformes (comme lâ€™utilisation systÃ©matique de mots-clÃ©s *Fixes/Closes* dans les descriptions de PR) garantit que la **fermeture des tickets** soit bien synchronisÃ©e avec le code mergeÌ.

En complÃ©ment, des GitHub Actions spÃ©cifiques pourront Ãªtre utilisÃ©es pour gÃ©rer des cas plus avancÃ©s. Par exemple, une Action peut Ã©tiqueter et dÃ©placer automatiquement une issue signalÃ©e par un utilisateur (via le feedback du site) dans *Triage* avec un label â€œcommunityâ€ et notifier lâ€™Ã©quipe. Une autre pourrait rappeler via Slack/Mail les issues restÃ©es trop longtemps en Review (pour encourager les reviewers Ã  finaliser). Globalement, ce **Kanban outillÃ©** offre une visibilitÃ© en temps rÃ©el sur lâ€™Ã©tat du projet et permet de repÃ©rer rapidement les points de blocage (ex: une carte stagnante en Review signale peut-Ãªtre un besoin dâ€™aide sur la revue).

### StratÃ©gie de labellisation pour la catÃ©gorisation des issues

Afin de faciliter le filtrage et le suivi des tickets, Nudger va mettre en place une **stratÃ©gie de labels** (aka : tags github issues)  couvrant plusieurs axes de catÃ©gorisation cohÃ©rents. Les principales catÃ©gories de labels envisagÃ©es incluentÂ :

- **Composant/Module impactÃ©Â :** pour indiquer la partie du systÃ¨me concernÃ©e par lâ€™issue. Par exemple, `component:frontend` (pour les problÃ¨mes UI/UX ou site web), `component:backend` (moteur de recherche, API), `component:crawler`, `component:SEO`, etc. Ce dÃ©coupage par composant permettra aux spÃ©cialistes de chaque domaine dâ€™identifier rapidement les tickets pertinents pour eux.
- **Type de ticketÂ :** pour distinguer la nature de lâ€™issue. On utilisera des labels tels que `type:bug` (anomalie Ã  corriger), `type:feature` (demande de nouvelle fonctionnalitÃ©), `type:enhancement` (amÃ©lioration mineure dâ€™une fonction existante), `type:discussion` (nÃ©cessite une dÃ©cision ou un design), `type:documentation` (mise Ã  jour de doc ou README), etc. Ces Ã©tiquettes aident Ã  filtrer (par exemple traiter dâ€™abord les bugs critiques) et donnent un contexte dÃ¨s la lecture du titre.
- **PrioritÃ©Â :** tous les tickets validÃ©s se verront attribuer un niveau de prioritÃ©. Une convention pourrait Ãªtre dâ€™utiliser des labels du style `priority:P0` (Urgent/Critique), `priority:P1` (Hautement prioritaire), `priority:P2` (Moyen), `priority:P3` (Faible). Ou de maniÃ¨re littÃ©raleÂ : `priority:high/medium/low`. La prioritÃ© est dÃ©cidÃ©e lors du triage et peut Ãªtre ajustÃ©e en cours de route si le contexte change. Elle indique lâ€™ordre de traitement recommandÃ© au sein du backlog.
- **Statut/Ã‰tat complÃ©mentaireÂ :** bien que le dÃ©placement dans les colonnes du Kanban renseigne lâ€™Ã©tat principal (Ã  faire, en cours, en revue, fait), on peut ajouter des labels pour des Ã©tats transverses. Par exemple `status:blocked` (si une issue est bloquÃ©e par une dÃ©pendance externe ou une dÃ©cision), `status:need specs` (si lâ€™issue requiert encore des prÃ©cisions avant dev), `status:duplicate` (si câ€™est un doublon dâ€™une autre issue), ou `wontfix` le cas Ã©chÃ©ant. Ces labels servent surtout pendant le triage et la revue du backlog pour signaler des situations particuliÃ¨res.
- **Source de la demandeÂ :** afin de tracer lâ€™origine dâ€™une idÃ©e ou dâ€™un bug, on peut taguer les issues avec `source:community` (retours utilisateurs via le site ou GitHub), `source:internal` (idÃ©e Ã©manant de lâ€™Ã©quipe interne), voire `source:partner` si une suggestion provient dâ€™un partenaire ou dâ€™un mentor. Ceci valorise lâ€™apport de la communautÃ© et peut influencer la priorisation (ex: une suggestion communautÃ© aura tendance Ã  Ãªtre priorisÃ©e si elle recueille des votes).
- **Engagement / accessibilitÃ© de la tÃ¢cheÂ :** Nudger souhaite aussi indiquer quelles tÃ¢ches sont **ouvertes aux contributeurs occasionnels ou learners**. On rÃ©utilisera pour cela les conventions GitHub existantesÂ : par exemple le label `good first issue` sera apposÃ© sur des tickets simples, bien cadrÃ©s, idÃ©aux pour un nouveau contributeur (learner) souhaitant faire sa premiÃ¨re PR. De mÃªme, un label `help wanted` peut signaler quâ€™une aide extÃ©rieure est la bienvenue sur un ticket (souvent utilisÃ© quand lâ€™Ã©quipe core manque de temps ou de compÃ©tences trÃ¨s pointues sur ce sujet). Ces labels â€œdâ€™engagementâ€ encouragent la communautÃ© Ã  mettre la main Ã  la pÃ¢te en identifiant ce sur quoi elle peut intervenir facilement. Ã€ lâ€™inverse, si certaines issues sont rÃ©servÃ©es Ã  lâ€™Ã©quipe core (soit pour des raisons de sÃ©curitÃ©, soit parce quâ€™elles nÃ©cessitent une connaissance profonde du systÃ¨me), on Ã©vitera de leur mettre `help wanted` et on peut les marquer en interne dâ€™un label du genre `core-only` (mÃªme si celui-ci ne sera pas mis en avant publiquement).

Chaque ticket se verra donc attribuer une **combinaison de labels** couvrant ces axes (ex: un bug critique sur le frontend demandÃ© par un utilisateur aura `type:bug`, `component:frontend`, `priority:P0`, `source:community`). Une utilisation **cohÃ©rente des libellÃ©s** est importanteÂ : lâ€™Ã©quipe dÃ©finira une nomenclature claire et veillera Ã  lâ€™appliquer lors du triage. Cela permettra dâ€™utiliser efficacement les filtres de GitHub (par exemple afficher toutes les features backend P1 en attente) et de gÃ©nÃ©rer des **vues personnalisÃ©es** dans GitHub Projects.

Le tag **votable** sera attribuÃ©e aux issues pour lequelle l'avis des utilisateurs est demandÃ©. Toute issue nouvellement crÃ©Ã©s **depuis les sites utilisateurs** se verront affecter cette etiquette **votable**

### Vues GitHub ProjectsÂ : publique vs interne

GitHub Projects (Beta) offre la possibilitÃ© de crÃ©er des **vues personnalisÃ©es** du board, ce que Nudger exploitera pour adresser diffÃ©remment le public externe et lâ€™Ã©quipe interne. Deux vues principales seront configurÃ©esÂ :

- **Vue publique (backlog communautaire)** â€“ Cette vue, rendue publique et facilement accessible (depuis le README ou le site Nudger via un lien), prÃ©sentera aux utilisateurs la liste des idÃ©es et Ã©volutions envisagÃ©es, avec la possibilitÃ© pour la communautÃ© de **voter** et commenter.

Cette backlog sera un filtrepour ne restituer que les issues tagguÃ©es **visibility:public**. Un usage classique peut Ãªtre d'avoir les issue "parent" en visibility::public, et les issues enfants en visibility:internal, permetant ainsi de garder un lien clair entre issues presentÃ©s au public et les taches de travail pilotÃ©s et utilisÃ©es par l'Ã©quipe interne.

ConcrÃ¨tement, cette vue affichera surtout les issues de type *feature requests* et suggestions ouvertes, probablement celles dans la colonne Backlog (ou une colonne dÃ©diÃ©e aux idÃ©es proposÃ©es ?). On peut filtrer pour ne montrer que les items marquÃ©s `source:community` ou ayant un label particulier signifiant â€œSuggestion dâ€™amÃ©liorationâ€.  Ces **votes utilisateurs** serviront de rÃ©fÃ©rence lors de la priorisationÂ : un tri par nombre de ðŸ‘ (ou un champ custom â€œVotesâ€) permettra dâ€™identifier les demandes les plus plÃ©biscitÃ©es. La vue publique sera prÃ©sentÃ©e de maniÃ¨re simple et transparente, sans informations techniques superflues â€“ par exemple, on nâ€™y affichera pas nÃ©cessairement les champs internes comme la complexitÃ© ou lâ€™assignee. Le but est que les contributeurs non techniques et utilisateurs puissent **suivre lâ€™avancement** du projet et se sentir impliquÃ©s dans les choix dâ€™Ã©volution. De mÃªme,

- **Vue interne (pilotage technique)** â€“ A destination de la Tribe (mais pour autant publiquement exposÃ©e pour les curieux) , la vue interne offrira un **tableau de bord complet** pour le suivi au jour le jour. Elle inclura lâ€™ensemble des colonnes (Triage, Backlog, In Progress, Review, Done) et toutes les issues, y compris les tÃ¢ches purement techniques ou de maintenance que la communautÃ© nâ€™a pas forcÃ©ment besoin de voir en prioritÃ©. Dans cette vue, on pourra afficher des champs supplÃ©mentaires comme lâ€™**assignation** (qui travaille sur quoi), la **prioritÃ© interne** (parfois lâ€™Ã©quipe peut ajuster lâ€™ordre indÃ©pendamment des votes publics, par exemple pour corriger un bug critique ayant peu de votes car peu visible du public), ou encore un champ **Ã©chÃ©ance** si certaines tÃ¢ches ont une deadline. La vue interne servira au **pilotage technique** lors des rÃ©unions dâ€™Ã©quipeÂ : on peut lâ€™utiliser en partage dâ€™Ã©cran durant le stand-up hebdo pour passer en revue chaque colonne. Elle permet Ã©galement aux membres de savoir sur quoi travaillent leurs collÃ¨gues en un coup dâ€™Å“il et de dÃ©tecter les surcharges (trop de cartes sur une personne, par exemple). Cette vue pourra Ãªtre privÃ©e (accessible uniquement aux membres du repo) si lâ€™Ã©quipe souhaite y mettre des commentaires ou champs confidentiels, mais comme le projet Nudger est public, mÃªme les aspects techniques pourraient en grande partie Ãªtre ouverts. Quoi quâ€™il en soit, la sÃ©paration des vues garantit une **lisibilitÃ© adaptÃ©e Ã  chaque audience**Â : le public voit lâ€™Ã©tat du produit et peut contribuer aux idÃ©es, lâ€™Ã©quipe voit le dÃ©tail opÃ©rationnel pour conduire le projet efficacement.

En somme, ces deux perspectives sur le mÃªme projet assurent la **transparence vis-Ã -vis des utilisateurs** tout en prÃ©servant un outil de travail complet et "end to end" pour lâ€™Ã©quipe. Cette configuration est Ã©volutiveÂ : Nudger pourra ajouter dâ€™autres vues filtrÃ©es (par exemple une vue â€œBugs onlyâ€ pour se concentrer sur la qualitÃ©, ou une vue par composant pour les squads frontend/backend).

Les taches autres que techniques (communication, redactionnel, gestion de projet) seront Ã©galement suivies de la mÃªme maniÃ¨re, afin d'offrir une vue complete et cohÃ©rente de l'integralitÃ© des tÃ¢ches du projt Nudger

## Release

Les releases sont des marqueurs importants et de cÃ©lebration. En mode dÃ©ploiement continue sur la cible, il convient pour autant d'animer et suivre les releases.

Pour cela, on utilisera du Semver, on visera a trouver une thematique de noms "Tribe, Green ? TODO : Action equipe", et on generera automatiquement les releases notes, comprenant les tÃ¢ches non techs. On visera si possible a animer ces releases de faÃ§on ouverte sur le blog et les rÃ©seaux

TODO : Expliquer
TODO : Les releases integrent aussi les taches non tech
TODO: Animation autour des Releases

> On gere les taches "projet / communication" egalement comme cela
PArler du cycle de Release
> 
