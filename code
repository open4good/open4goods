# Directory structure 
- pom.xml
- src
--- main
---- java
----- org
------ open4goods
------- services
-------- reviewgeneration
--------- config
---------- ReviewGenerationConfig.java
--------- dto
---------- ReviewGenerationStatus.java
---------- ReviewRequest.java
--------- service
---------- ReviewGenerationService.java
---- resources
----- META-INF
------ additional-spring-configuration-metadata.json
--- test
---- java
----- org
------ open4goods
------- reviewgeneration
-------- ReviewGenerationServiceTest.java
---- resources
----- application-test.yml

# Files content

## [ReviewGenerationService.java - /home/goulven/git/open4goods/services/review-generation/src/main/java/org/open4goods/services/reviewgeneration/service/ReviewGenerationService.java]
~~~
package org.open4goods.services.reviewgeneration.service;

import java.net.URL;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.function.Predicate;

import org.open4goods.model.ai.AiReview;
import org.open4goods.model.product.Product;
import org.open4goods.model.vertical.VerticalConfig;
import org.open4goods.services.googlesearch.dto.GoogleSearchRequest;
import org.open4goods.services.googlesearch.dto.GoogleSearchResponse;
import org.open4goods.services.googlesearch.dto.GoogleSearchResult;
import org.open4goods.services.googlesearch.service.GoogleSearchService;
import org.open4goods.services.productrepository.services.ProductRepository;
import org.open4goods.services.prompt.dto.PromptResponse;
import org.open4goods.services.prompt.service.PromptService;
import org.open4goods.services.reviewgeneration.config.ReviewGenerationConfig;
import org.open4goods.services.reviewgeneration.dto.ReviewGenerationStatus;
import org.open4goods.services.reviewgeneration.dto.ReviewGenerationStatus.Status;
import org.open4goods.services.urlfetching.dto.FetchResponse;
import org.open4goods.services.urlfetching.service.UrlFetchingService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Service;

import io.micrometer.core.instrument.MeterRegistry;

/**
 * Service for generating AI-assisted reviews.
 * <p>
 * This implementation has been refactored to use a new review generation logic:
 * <ol>
 *   <li>Before launching AI review generation, a preprocessing check is performed:
 *       <ul>
 *         <li>If the product does not have an associated AI review, generation proceeds.</li>
 *         <li>If a review exists, it is only regenerated if its creation date is older than the configured refresh delay (default 6 months).</li>
 *       </ul>
 *   </li>
 *   <li>It builds search queries using the product’s brand and model (and alternate models) with a query template.
 *       A maximum of {@code maxSearch} queries are performed.</li>
 *   <li>All search results are then sorted so that URLs containing preferred domains (configured via {@code preferredDomains})
 *       appear first.</li>
 *   <li>Next, URLs are fetched concurrently (up to {@code maxConcurrentFetch} tasks in parallel).
 *       For each fetched URL, the PromptService.estimateTokens() method is used to count tokens.
 *       Only pages with at least {@code sourceMinTokens} tokens are accepted and pages are aggregated until the total tokens
 *       reach {@code maxTotalTokens}.</li>
 *   <li>Finally, the collected markdown contents are passed as prompt variables to generate the review.</li>
 * </ol>
 * <p>
 * After generating the review, the product is updated with the new AI review and re-indexed using {@code productRepository.forceIndex()}.
 * <p>
 * The service supports both synchronous and asynchronous calls and tracks process status in memory.
 * It also implements HealthIndicator to report service health based on generation failures.
 */
@Service
public class ReviewGenerationService implements HealthIndicator {

    private static final Logger logger = LoggerFactory.getLogger(ReviewGenerationService.class);

    private final ReviewGenerationConfig properties;
    private final GoogleSearchService googleSearchService;
    private final UrlFetchingService urlFetchingService;
    private final PromptService genAiService;
    private final MeterRegistry meterRegistry;
    private final ProductRepository productRepository;

    // Thread pool executor for asynchronous processing.
    private final ThreadPoolExecutor executorService;

    // In-memory storage of process status keyed by UPC.
    private final ConcurrentMap<Long, ReviewGenerationStatus> processStatusMap = new ConcurrentHashMap<>();

    // Global metrics for review generations.
    private final AtomicInteger totalProcessed = new AtomicInteger(0);
    private final AtomicInteger successfulCount = new AtomicInteger(0);
    private final AtomicInteger failedCount = new AtomicInteger(0);

    // Flag used by the health check: set to true if any generation failed.
    private volatile boolean lastGenerationFailed = false;

    /**
     * Constructs a new ReviewGenerationService.
     *
     * @param properties the review generation configuration properties.
     * @param googleSearchService the Google search service.
     * @param urlFetchingService the URL fetching service.
     * @param genAiService the Gen AI service.
     * @param meterRegistry the actuator meter registry.
     * @param productRepository the product repository service.
     */
    public ReviewGenerationService(ReviewGenerationConfig properties,
                                   GoogleSearchService googleSearchService,
                                   UrlFetchingService urlFetchingService,
                                   PromptService genAiService,
                                   MeterRegistry meterRegistry,
                                   ProductRepository productRepository) {
        this.properties = properties;
        this.googleSearchService = googleSearchService;
        this.urlFetchingService = urlFetchingService;
        this.genAiService = genAiService;
        this.meterRegistry = meterRegistry;
        this.productRepository = productRepository;
        this.executorService = new ThreadPoolExecutor(
            properties.getThreadPoolSize(),
            properties.getThreadPoolSize(),
            0L,
            TimeUnit.MILLISECONDS,
            new ArrayBlockingQueue<>(properties.getMaxQueueSize()),
            new ThreadPoolExecutor.AbortPolicy()
        );
    }

    /**
     * Checks if a review generation process for the given GTIN is already active.
     *
     * @param gtin the product GTIN.
     * @return true if an active process exists; false otherwise.
     */
    private boolean isActiveForGtin(String gtin) {
        return processStatusMap.values().stream()
                .anyMatch(s -> s.getGtin() != null && s.getGtin().equals(gtin)
                        && s.getStatus() != Status.SUCCESS && s.getStatus() != Status.FAILED);
    }

    /**
     * Synchronously generates a review for the given product and vertical configuration.
     * <p>
     * Preprocessing check: If the product already has an AI review and it is not older than the configured refresh delay,
     * the existing review is returned without triggering a new generation.
     *
     * @param product the product containing brand, primary model, and alternate models.
     * @param verticalConfig the vertical configuration.
     * @return the generated or existing AI review.
     */
    public AiReview generateReviewSync(Product product, VerticalConfig verticalConfig) {
        long upc = product.getId();

        // Preprocessing: Check if review generation is necessary.
        if (!shouldGenerateReview(product)) {
            logger.info("Skipping AI review generation for UPC {} because an up-to-date review already exists.", upc);
            //TODO(p3,i18n) : i18n
            return product.getAiReviews().i18n("fr");
        }

        // Check duplicate submission for same GTIN.
        if (isActiveForGtin(product.gtin())) {
            throw new IllegalStateException("Review generation already in progress for product with GTIN " + product.gtin());
        }

        ReviewGenerationStatus status = new ReviewGenerationStatus();
        status.setUpc(upc);
        status.setGtin(product.gtin());
        status.setStatus(Status.PENDING);
        status.setStartTime(Instant.now().toEpochMilli());
        processStatusMap.put(upc, status);

        try {
            PromptResponse<AiReview> reviewResponse = executeReviewGeneration(product, verticalConfig, status);
            AiReview newReview = reviewResponse.getBody();
            status.setResult(newReview);
            status.setStatus(Status.SUCCESS);
            status.setEndTime(Instant.now().toEpochMilli());
            computeTimings(status);
            successfulCount.incrementAndGet();
            meterRegistry.counter("review.generation.success").increment();
            // Update product with the new AI review and force index update.
            //TODO(p3,i18n) : i18n
            product.getAiReviews().put("fr", newReview);
            productRepository.forceIndex(product);
            return newReview;
        } catch (Exception e) {
            logger.error("Review generation failed for UPC {}: {}", upc, e.getMessage(), e);
            status.setStatus(Status.FAILED);
            status.setErrorMessage(e.getMessage());
            status.setEndTime(Instant.now().toEpochMilli());
            computeTimings(status);
            failedCount.incrementAndGet();
            meterRegistry.counter("review.generation.failed").increment();
            lastGenerationFailed = true;
            throw new RuntimeException("Review generation failed", e);
        } finally {
            totalProcessed.incrementAndGet();
        }
    }

    /**
     * Asynchronously initiates review generation for the given product and vertical configuration.
     * <p>
     * Preprocessing check: If the product already has an AI review and it is not older than the configured refresh delay,
     * the generation is skipped and the existing review remains.
     *
     * @param product the product containing brand, primary model, and alternate models.
     * @param verticalConfig the vertical configuration.
     * @return the process ID (UPC) used to track generation status.
     */
    public long generateReviewAsync(Product product, VerticalConfig verticalConfig) {
        long upc = product.getId();

        // Preprocessing: Check if review generation is necessary.
        if (!shouldGenerateReview(product)) {
            logger.info("Skipping asynchronous AI review generation for UPC {} because an up-to-date review already exists.", upc);
            ReviewGenerationStatus status = new ReviewGenerationStatus();
            status.setUpc(upc);
            status.setGtin(product.gtin());
            status.setStatus(Status.SUCCESS);
            status.addMessage("Existing valid AI review found. Skipping generation.");
            status.setStartTime(Instant.now().toEpochMilli());
            status.setEndTime(Instant.now().toEpochMilli());
            computeTimings(status);
            processStatusMap.put(upc, status);
            return upc;
        }

        // Check duplicate submission for same GTIN.
        if (isActiveForGtin(product.gtin())) {
            throw new IllegalStateException("Review generation already in progress for product with GTIN " + product.gtin());
        }

        // Avoid duplicate runs on the same UPC if already processing.
        processStatusMap.compute(upc, (key, existingStatus) -> {
            if (existingStatus != null && (existingStatus.getStatus() == Status.PENDING ||
                    existingStatus.getStatus() == Status.QUEUED ||
                    existingStatus.getStatus() == Status.SEARCHING ||
                    existingStatus.getStatus() == Status.FETCHING ||
                    existingStatus.getStatus() == Status.ANALYSING)) {
                return existingStatus;
            } else {
                ReviewGenerationStatus status = new ReviewGenerationStatus();
                status.setUpc(upc);
                status.setGtin(product.gtin());
                status.setStatus(Status.PENDING);
                status.setStartTime(Instant.now().toEpochMilli());
                return status;
            }
        });

        // Submit the review generation task asynchronously.
        executorService.submit(() -> {
            ReviewGenerationStatus status = processStatusMap.get(upc);
            // Update status as the task starts execution.
            status.setStatus(Status.SEARCHING);
            try {
                PromptResponse<AiReview> reviewResponse = executeReviewGeneration(product, verticalConfig, status);
                AiReview newReview = reviewResponse.getBody();
                status.setResult(newReview);
                status.setStatus(Status.SUCCESS);
                // Update product with the new AI review and force index update.
                //TODO(p3, i18n) : i18n
                product.getAiReviews().put("fr", newReview);
                productRepository.forceIndex(product);
                meterRegistry.counter("review.generation.success").increment();
            } catch (Exception e) {
                logger.error("Asynchronous review generation failed for UPC {}: {}", upc, e.getMessage(), e);
                status.setStatus(Status.FAILED);
                status.setErrorMessage(e.getMessage());
                meterRegistry.counter("review.generation.failed").increment();
                lastGenerationFailed = true;
            } finally {
                status.setEndTime(Instant.now().toEpochMilli());
                computeTimings(status);
                totalProcessed.incrementAndGet();
            }
        });

        // Immediately after submission, update the status to QUEUED.
        int waiting = executorService.getQueue().size();
        ReviewGenerationStatus status = processStatusMap.get(upc);
        status.setStatus(Status.QUEUED);
        status.addMessage("Queued for execution. Number waiting in queue: " + waiting);

        return upc;
    }

    /**
     * Executes the review generation process using the new logic.
     * <ol>
     *   <li>Builds search queries using the product’s brand and primary model and then alternate models using the configured query template.
     *       A maximum of {@code maxSearch} queries are performed.</li>
     *   <li>Performs a Google search for each query and aggregates the search results.</li>
     *   <li>Deduplicates the search results to keep only one URL per distinct domain, and then sorts the results so that
     *       results from preferred domains come first.</li>
     *   <li>Fetches the markdown content for each URL concurrently (up to {@code maxConcurrentFetch} tasks).
     *       For each fetched page, its token count is estimated via {@code PromptService.estimateTokens(String text)}.
     *       Pages with token counts below {@code sourceMinTokens} are discarded and pages are aggregated until
     *       the total token count reaches {@code maxTotalTokens}.</li>
     *   <li>Finally, the aggregated markdown content is passed as a prompt variable to generate the review.</li>
     * </ol>
     * <p>
     * During the process, the provided {@code ProcessStatus} is updated with messages that track key steps.
     *
     * @param product the product.
     * @param verticalConfig the vertical configuration.
     * @param status the process status to update with processing messages.
     * @return the generated review.
     * @throws Exception if an error occurs during generation.
     */
    private PromptResponse<AiReview> executeReviewGeneration(Product product, VerticalConfig verticalConfig, ReviewGenerationStatus status) throws Exception {
        String brand = product.brand();
        String primaryModel = product.model();
        Set<String> alternateModels = product.getAkaModels();

        // Build a list of search queries using the configured query template.
        List<String> queries = new ArrayList<>();
        queries.add(String.format(properties.getQueryTemplate(), brand, primaryModel));
        if (alternateModels != null) {
            for (String akaModel : alternateModels) {
                queries.add(String.format(properties.getQueryTemplate(), brand, akaModel));
            }
        }

        // Record initial message for search queries.
        status.addMessage("Searching the web...");

        // (Status already set to SEARCHING in caller)

        // Perform searches up to the maximum allowed (maxSearch).
        int searchesMade = 0;
        List<GoogleSearchResult> allResults = new ArrayList<>();
        int maxSearch = properties.getMaxSearch();
        for (String query : queries) {
            if (searchesMade >= maxSearch) {
                break;
            }
            logger.debug("Executing search query: {}", query);
            status.addMessage("Executing search query: " + query);
            //TODO(p3,i18N) : internationalisation from ReviewGenConfig
            GoogleSearchRequest searchRequest = new GoogleSearchRequest(query, "lang_fr", "countryFR");
            GoogleSearchResponse searchResponse = googleSearchService.search(searchRequest);
            searchesMade++;
            if (searchResponse != null && searchResponse.getResults() != null) {
                allResults.addAll(searchResponse.getResults());
            }
        }

        // Update status to FETCHING before starting URL fetch.
        status.setStatus(Status.FETCHING);

        // Deduplicate and sort the search results:
        // 1. Keep only one URL per distinct domain.
        // 2. Sort so that entries from preferred domains come first.
        List<GoogleSearchResult> sortedResults = allResults.stream()
                .filter(r -> r.getLink() != null && !r.getLink().isEmpty())
                // excluding pdf
                .filter(r -> !r.getLink().endsWith(".pdf"))
                .filter(distinctByKey(r -> {
                    try {
                        return new URL(r.getLink()).getHost();
                    } catch (Exception e) {
                        return r.getLink();
                    }
                }))
                .sorted((r1, r2) -> {
                    boolean r1Preferred = properties.getPreferredDomains().stream()
                            .anyMatch(domain -> r1.getLink().contains(domain));
                    boolean r2Preferred = properties.getPreferredDomains().stream()
                            .anyMatch(domain -> r2.getLink().contains(domain));
                    if (r1Preferred && !r2Preferred) return -1;
                    if (!r1Preferred && r2Preferred) return 1;
                    return 0;
                })
                .toList();

        // Prepare to fetch URL content concurrently using a dedicated executor.
        ThreadPoolExecutor fetchExecutor = new ThreadPoolExecutor(
            properties.getMaxConcurrentFetch(),
            properties.getMaxConcurrentFetch(),
            0L,
            TimeUnit.MILLISECONDS,
            new ArrayBlockingQueue<>(properties.getMaxQueueSize()),
            new ThreadPoolExecutor.AbortPolicy()
        );
        Map<String, CompletableFuture<FetchResponse>> fetchFutures = new HashMap<>();
        for (GoogleSearchResult result : sortedResults) {
            String url = result.getLink();
            CompletableFuture<FetchResponse> future = CompletableFuture.supplyAsync(() -> {
                try {
                    return urlFetchingService.fetchUrl(url).get();
                } catch (Exception e) {
                    logger.warn("Failed to fetch content from URL {}: {}", url, e.getMessage());
                    return null;
                }
            }, fetchExecutor);
            fetchFutures.put(url, future);
        }
        fetchExecutor.shutdown();

        // Update status to ANALYSING before processing fetched content.
        status.setStatus(Status.ANALYSING);
        status.addMessage("Fetching URL content concurrently...");

        // Aggregate fetched markdown content until the maximum token limit is reached.
        int maxTotalTokens = properties.getMaxTotalTokens();
        int minTokens = properties.getSourceMinTokens();
        int maxTokens = properties.getSourceMaxTokens();
        
        int accumulatedTokens = 0;
        Map<String, String> finalSourcesMap = new LinkedHashMap<>();
        Map<String, Integer> finalTokensMap = new LinkedHashMap<>();
        
        // Process the sorted URLs in order.
        for (GoogleSearchResult result : sortedResults) {
            String url = result.getLink();
            CompletableFuture<FetchResponse> future = fetchFutures.get(url);
            if (future == null) continue;
            FetchResponse fetchResponse = future.get();
            if (fetchResponse == null || fetchResponse.markdownContent() == null || fetchResponse.markdownContent().isEmpty()) {
                continue;
            }
            String content = fetchResponse.markdownContent();
            int tokenCount = genAiService.estimateTokens(content);
            if (tokenCount < minTokens) {
                logger.warn("Content from URL {} discarded due to insufficient tokens: {}", url, tokenCount);
                continue;
            }
            if (tokenCount > maxTokens) {
                logger.warn("Content from URL {} discarded, exceed tokens limit: {}", url, tokenCount);
                continue;
            }
            
            if (accumulatedTokens + tokenCount > maxTotalTokens) {
                logger.warn("Reached max tokens threshold. Current tokens: {}, URL tokens: {}, threshold: {}",
                        accumulatedTokens, tokenCount, maxTotalTokens);
                break;
            }
            finalSourcesMap.put(url, content);
            finalTokensMap.put(url, tokenCount);
            accumulatedTokens += tokenCount;
            // Record message for the analysed URL, including its domain.
            try {
                String domain = new URL(url).getHost();
                status.addMessage("Analysing " + domain);
            } catch (Exception e) {
                status.addMessage("Analysing " + url);
            }
        }
        logger.info("Aggregated {} tokens from {} sources.", accumulatedTokens, finalSourcesMap.size());

        // Compose the prompt variables including the collected markdown content.
        Map<String, Object> promptVariables = new HashMap<>();
        promptVariables.put("sources", finalSourcesMap);
        promptVariables.put("tokens", finalTokensMap);
        
        promptVariables.put("PRODUCT_NAME", product.shortestOfferName());
        promptVariables.put("PRODUCT_BRAND", product.brand());
        promptVariables.put("PRODUCT_MODEL", product.model());
        promptVariables.put("PRODUCT_GTIN", product.gtin());
        promptVariables.put("PRODUCT", product);
		
        promptVariables.put("VERTICAL_NAME", verticalConfig.i18n("fr").getH1Title().getPrefix());

        StringBuilder sb = new StringBuilder();
        verticalConfig.getAttributesConfig().getConfigs().forEach(attrConf -> {
            if (attrConf.getSynonyms().size() > 0 ) {
                sb.append("        ").append("- ").append(attrConf.getKey()).append(" (").append(attrConf.getName().get("fr")).append(")").append("\n");				
            }
        });
        promptVariables.put("ATTRIBUTES", sb.toString());
		
        status.addMessage("AI generation");
        // Generate the review using the GenAiService with the prompt template "review-generation".
        PromptResponse<AiReview> ret = genAiService.objectPrompt("review-generation", promptVariables, AiReview.class);
        return ret;
    }

    /**
     * Determines if a new AI review should be generated for the product.
     * <p>
     * Generation is required if:
     * <ul>
     *   <li>The product does not have an associated AI review.</li>
     *   <li>Or the existing review's creation date is older than the configured refresh delay.</li>
     * </ul>
     *
     * @param product the product to check.
     * @return true if generation should proceed; false otherwise.
     */
    private boolean shouldGenerateReview(Product product) {
        // TODO(p3, i18n)
        AiReview existingReview = product.getAiReviews().i18n("fr");
        if (existingReview == null) {
            return true;
        }
        
        // TODO : HAndle the time limit we can generate again
//        Instant reviewCreated = Instant.ofEpochMilli(existingReview.createdMs());
//        Instant threshold = Instant.now().minus(properties.getRefreshDelayMonths(), ChronoUnit.MONTHS);
//        return reviewCreated.isBefore(threshold);
        
        return false;
    }

    /**
     * Computes and sets the duration and remaining time for a given process.
     *
     * @param status the process status to update.
     */
    private void computeTimings(ReviewGenerationStatus status) {
        if (status.getStartTime() != null && status.getEndTime() != null) {
            long duration = status.getEndTime() - status.getStartTime();
            long estimated = properties.getEstimatedTime();
            long remaining = estimated - duration;
            status.setDuration(duration);
            status.setRemaining(remaining);
            status.setPercent(new Long (Math.round(Double.valueOf(duration) / Double.valueOf(estimated) * 100)).intValue());
        }
    }
    
    /**
     * Updates the timings dynamically for an ongoing process.
     *
     * @param status the process status to update.
     */
    private void updateDynamicTimings(ReviewGenerationStatus status) {
        if (status.getStartTime() != null && (status.getStatus() != Status.SUCCESS && status.getStatus() != Status.FAILED)) {
            long elapsed = Instant.now().toEpochMilli() - status.getStartTime();
            long estimated = properties.getEstimatedTime();
            long remaining = Math.max(estimated - elapsed, 0);
            int percent = (int) Math.min(100, Math.round((double) elapsed / estimated * 100));
            status.setDuration(elapsed);
            status.setRemaining(remaining);
            status.setPercent(percent);
        }
    }

    /**
     * Returns the status of a review generation process by UPC.
     *
     * @param upc the UPC identifier.
     * @return the process status, or null if not found.
     */
    public ReviewGenerationStatus getProcessStatus(long upc) {
        ReviewGenerationStatus status = processStatusMap.get(upc);
        if (status != null && status.getStatus() != Status.SUCCESS && status.getStatus() != Status.FAILED) {
            updateDynamicTimings(status);
        }
        return status;
    }

    /**
     * Returns global processing statistics.
     *
     * @return a map with keys: totalProcessed, successful, failed, and ongoing.
     */
    public Map<String, Integer> getGlobalStats() {
        Map<String, Integer> stats = new HashMap<>();
        stats.put("totalProcessed", totalProcessed.get());
        stats.put("successful", successfulCount.get());
        stats.put("failed", failedCount.get());
        // Count processes that are still PENDING, QUEUED, SEARCHING, FETCHING or ANALYSING.
        long ongoing = processStatusMap.values().stream()
                .filter(s -> s.getStatus() == Status.PENDING ||
                             s.getStatus() == Status.QUEUED ||
                             s.getStatus() == Status.SEARCHING ||
                             s.getStatus() == Status.FETCHING ||
                             s.getStatus() == Status.ANALYSING)
                .count();
        stats.put("ongoing", (int) ongoing);
        return stats;
    }

    /**
     * Health check implementation.
     * <p>
     * The service is reported as DOWN if any review generation failure has occurred.
     *
     * @return Health status UP if healthy; otherwise DOWN with error details.
     */
    @Override
    public Health health() {
        if (lastGenerationFailed) {
            return Health.down().withDetail("error", "One or more review generations have failed").build();
        }
        return Health.up().build();
    }

    /**
     * Returns a predicate that maintains state about what keys have been seen so far, filtering out duplicates.
     *
     * @param keyExtractor a function to extract the key for comparison.
     * @param <T> the type of the input elements.
     * @return a predicate that returns true if the element is encountered for the first time.
     */
    private static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {
        Map<Object, Boolean> seen = new ConcurrentHashMap<>();
        return t -> seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
~~~

## [ReviewGenerationServiceTest.java - /home/goulven/git/open4goods/services/review-generation/src/test/java/org/open4goods/reviewgeneration/ReviewGenerationServiceTest.java]
~~~
// TODO : Have to mock product repository
package org.open4goods.reviewgeneration;
//
//import static org.junit.jupiter.api.Assertions.assertEquals;
//import static org.junit.jupiter.api.Assertions.assertNotNull;
//import static org.junit.jupiter.api.Assertions.assertTrue;
//import static org.junit.jupiter.api.Assertions.fail;
//
//import java.util.Set;
//
//import org.junit.jupiter.api.Test;
//import org.open4goods.googlesearch.mock.GoogleSearchServiceMock;
//import org.open4goods.model.ai.AiReview;
//import org.open4goods.model.attribute.ReferentielKey;
//import org.open4goods.model.product.Product;
//import org.open4goods.model.vertical.PrefixedAttrText;
//import org.open4goods.model.vertical.ProductI18nElements;
//import org.open4goods.model.vertical.VerticalConfig;
//import org.open4goods.services.prompt.service.mock.PromptServiceMock;
//import org.open4goods.services.reviewgeneration.config.ReviewGenerationConfig;
//import org.open4goods.services.reviewgeneration.dto.ReviewGenerationStatus;
//import org.open4goods.services.reviewgeneration.service.ReviewGenerationService;
//import org.open4goods.urlfetching.service.mock.UrlFetchingServiceMock;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.boot.SpringBootConfiguration;
//import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
//import org.springframework.boot.test.context.SpringBootTest;
//import org.springframework.context.annotation.ComponentScan;
//import org.springframework.context.annotation.Import;
//import org.springframework.test.context.ActiveProfiles;
//import org.springframework.test.context.TestPropertySource;
//
//@SpringBootTest(classes = {ReviewGenerationService.class, ReviewGenerationConfig.class, ReviewGenerationServiceTest.TestConfig.class})
//@TestPropertySource(locations = "classpath:application-test.yml")
//@ActiveProfiles("test")
//@Import({GoogleSearchServiceMock.class, UrlFetchingServiceMock.class, PromptServiceMock.class})
//public class ReviewGenerationServiceTest {
//
//    /**
//     * Minimal test configuration to bootstrap the Spring context.
//     */
//    @SpringBootConfiguration
//    @EnableAutoConfiguration
//    @ComponentScan(basePackages = {"org.open4goods.services"})
//    public static class TestConfig {
//        // This class remains empty; its purpose is to trigger component scanning.
//    }
//
//    @Autowired
//    private ReviewGenerationService reviewGenerationService;
//
////    @Test
////    public void testGenerateReviewSync() {
////        // Create a dummy product.
////        Product product = new Product();
////        product.setId(8806091548818L);
////        product.getAttributes().getReferentielAttributes().put(ReferentielKey.BRAND, "LG");
////        product.getAttributes().getReferentielAttributes().put(ReferentielKey.MODEL, "24TQ510S");
////        product.setAkaModels(Set.of("24TQ510S-PZ.API", "24TQ510S-PZ"));
////        // Assume product has a setter for GTIN.
////        product.setId(123L);
////
////        // Dummy vertical configuration.
////        VerticalConfig verticalConfig = new VerticalConfig();
////        verticalConfig.setId("tv");
////        ProductI18nElements i18n = new ProductI18nElements();
////        PrefixedAttrText p = new PrefixedAttrText();
////        p.setPrefix("téléviseur");
////        i18n.setH1Title(p);
////        verticalConfig.getI18n().put("fr", i18n);
////
////        // Invoke synchronous review generation.
////        try {
////            AiReview review = reviewGenerationService.generateReviewSync(product, verticalConfig);
////            assertNotNull(review, "The generated review should not be null");
////            System.out.println("Generated Review: " + review);
////        } catch (Exception e) {
////            fail("Review generation failed: ", e);
////        }
////
////        // Verify that the process status is SUCCESS and that processing messages were recorded.
////        ReviewGenerationStatus status = reviewGenerationService.getProcessStatus(product.getId());
////        assertNotNull(status, "Process status should be available");
////        assertEquals(ReviewGenerationStatus.Status.SUCCESS, status.getStatus());
////        assertTrue(status.getMessages().stream().anyMatch(msg -> msg.contains("Searching the web")),
////                "Process messages should contain a web search message");
////        assertTrue(status.getMessages().stream().anyMatch(msg -> msg.contains("AI generation")),
////                "Process messages should contain an AI generation message");
////    }
//    
//    /**
//     * New test case to verify that the URL content token thresholds and accumulation behave as expected.
//     * This test simulates:
//     * <ul>
//     *   <li>A Google search returning two URLs.</li>
//     *   <li>One URL returns content with an estimated token count above the minimum threshold.
//     *       The other returns content with too few tokens.</li>
//     *   <li>The aggregated tokens should include only the valid content and stop accumulation when reaching the maximum tokens limit.</li>
//     * </ul>
//     */
////    @Test
////    public void testGenerateReviewSyncTokenLimits() {
////        // Create a dummy product.
////        Product product = new Product();
////        product.setId(1234567890123L);
////        product.getAttributes().getReferentielAttributes().put(ReferentielKey.BRAND, "TestBrand");
////        product.getAttributes().getReferentielAttributes().put(ReferentielKey.MODEL, "TestModel");
////        product.setId(123L);
////        // No alternate models for simplicity.
////        
////        // Dummy vertical configuration.
////        VerticalConfig verticalConfig = new VerticalConfig();
////        verticalConfig.setId("testVertical");
////        ProductI18nElements i18n = new ProductI18nElements();
////        PrefixedAttrText p = new PrefixedAttrText();
////        p.setPrefix("TestVertical");
////        i18n.setH1Title(p);
////        verticalConfig.getI18n().put("fr", i18n);
////
////        try {
////            AiReview review = reviewGenerationService.generateReviewSync(product, verticalConfig);
////            assertNotNull(review, "The generated review should not be null");
////            System.out.println("Generated Review with token limits: " + review);
////        } catch (Exception e) {
////            fail("Review generation with token limits failed: ", e);
////        }
////    }
////    
//    /**
//     * New test case to verify that duplicate submissions for the same GTIN are disabled.
//     */
//    @Test
//    public void testDuplicateSubmission() {
//        // Create a dummy product.
//        Product product = new Product();
//        product.setId(1111111111111L);
//        product.getAttributes().getReferentielAttributes().put(ReferentielKey.BRAND, "DuplicateBrand");
//        product.getAttributes().getReferentielAttributes().put(ReferentielKey.MODEL, "Model1");
//        product.setAkaModels(Set.of());
//        product.setId(0L);
//        
//        // Dummy vertical configuration.
//        VerticalConfig verticalConfig = new VerticalConfig();
//        verticalConfig.setId("dup");
//        ProductI18nElements i18n = new ProductI18nElements();
//        PrefixedAttrText p = new PrefixedAttrText();
//        p.setPrefix("Duplicate");
//        i18n.setH1Title(p);
//        verticalConfig.getI18n().put("fr", i18n);
//        
//        // First submission (async) should succeed.
//        long upc1 = reviewGenerationService.generateReviewAsync(product, verticalConfig);
//        // Second submission with same GTIN should throw an exception.
//        try {
//            reviewGenerationService.generateReviewAsync(product, verticalConfig);
//            fail("Expected an exception for duplicate submission with same GTIN");
//        } catch (IllegalStateException e) {
//            // Expected exception.
//            System.out.println("Caught expected duplicate submission exception: " + e.getMessage());
//        }
//    }
//}
~~~

## [additional-spring-configuration-metadata.json - /home/goulven/git/open4goods/services/review-generation/src/main/resources/META-INF/additional-spring-configuration-metadata.json]
~~~
{
  "groups": [
    {
      "name": "review.generation",
      "type": "org.open4goods.services.reviewgeneration.config.ReviewGenerationConfig",
      "sourceType": "org.open4goods.services.reviewgeneration.config.ReviewGenerationConfig"
    }
  ],
  "properties": [
    {
      "name": "review.generation.thread-pool-size",
      "type": "java.lang.Integer",
      "description": "Number of threads allocated for processing.",
      "defaultValue": 10
    },
    {
      "name": "review.generation.max-queue-size",
      "type": "java.lang.Integer",
      "description": "Maximum size of the executor queue.",
      "defaultValue": 100
    },
    {
      "name": "review.generation.preferred-domains",
      "type": "java.util.List<java.lang.String>",
      "description": "List of preferred domains to fetch content from.",
      "defaultValue": []
    },
    {
      "name": "review.generation.query-template",
      "type": "java.lang.String",
      "description": "Template for constructing search queries.",
      "defaultValue": "test %s \"%s\""
    },
    {
      "name": "review.generation.max-search",
      "type": "java.lang.Integer",
      "description": "Maximum number of search queries allowed.",
      "defaultValue": 2
    },
    {
      "name": "review.generation.max-total-tokens",
      "type": "java.lang.Integer",
      "description": "Maximum total number of tokens allowed for aggregation.",
      "defaultValue": 100000
    },
    {
      "name": "review.generation.source-min-tokens",
      "type": "java.lang.Integer",
      "description": "Minimum number of tokens required for a source to be considered.",
      "defaultValue": 150
    },
    {
      "name": "review.generation.source-max-tokens",
      "type": "java.lang.Integer",
      "description": "Maximum number of tokens allowed per source.",
      "defaultValue": 10000
    },
    {
      "name": "review.generation.max-concurrent-fetch",
      "type": "java.lang.Integer",
      "description": "Maximum number of concurrent URL fetch operations.",
      "defaultValue": 3
    },
    {
      "name": "review.generation.refresh-delay-months",
      "type": "java.lang.Integer",
      "description": "Delay in months after which an existing AI review is considered outdated.",
      "defaultValue": 6
    },
    {
      "name": "review.generation.estimated-time",
      "type": "java.time.Duration",
      "description": "Estimated time for review generation process. Used to compute remaining time.",
      "defaultValue": "PT2M"
    }
  ]
}
~~~

## [ReviewGenerationStatus.java - /home/goulven/git/open4goods/services/review-generation/src/main/java/org/open4goods/services/reviewgeneration/dto/ReviewGenerationStatus.java]
~~~
package org.open4goods.services.reviewgeneration.dto;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import org.open4goods.model.ai.AiReview;

/**
 * DTO representing the status of a review generation process.
 */
public class ReviewGenerationStatus {

    /**
     * Possible states of a generation process.
     */
    public enum Status {
        PENDING, 
        QUEUED, 
        SEARCHING, 
        FETCHING, 
        ANALYSING, 
        SUCCESS, 
        FAILED;
    }
    
    private long upc;
    private Status status;
    private Long startTime;
    private Long endTime;
    private AiReview result;
    private String errorMessage;
    private Integer percent = 0;
    
    /**
     * List of processing messages that track the internal state.
     */
    private List<String> messages = new ArrayList<>();
    
    /**
     * Duration of the review generation process in milliseconds.
     */
    private long duration;
    
    /**
     * Remaining time (in milliseconds) computed as estimatedTime - duration.
     */
    private long remaining;
    
    /**
     * The product GTIN associated with the generation request.
     */
    private String gtin;

    // Getters and setters

    public long getUpc() {
        return upc;
    }

    public void setUpc(long upc) {
        this.upc = upc;
    }

    public Status getStatus() {
        return status;
    }

    public void setStatus(Status status) {
        this.status = status;
    }


    public Long getStartTime() {
		return startTime;
	}

	public void setStartTime(Long startTime) {
		this.startTime = startTime;
	}

	public Long getEndTime() {
		return endTime;
	}

	public void setEndTime(Long endTime) {
		this.endTime = endTime;
	}

	public AiReview getResult() {
        return result;
    }

    public void setResult(AiReview result) {
        this.result = result;
    }

    public String getErrorMessage() {
        return errorMessage;
    }

    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }

    public List<String> getMessages() {
        return messages;
    }

    public void setMessages(List<String> messages) {
        this.messages = messages;
    }
    
    /**
     * Appends a new message to the process status messages.
     *
     * @param message the message to add.
     */
    public void addMessage(String message) {
        this.messages.add(message);
    }
    
    public long getDuration() {
        return duration;
    }
    
    public void setDuration(long duration) {
        this.duration = duration;
    }
    
    public long getRemaining() {
        return remaining;
    }
    
    public void setRemaining(long remaining) {
        this.remaining = remaining;
    }
    
    public String getGtin() {
        return gtin;
    }
    
    public void setGtin(String gtin) {
        this.gtin = gtin;
    }

    
    
    
    // toString, equals, and hashCode

    public Integer getPercent() {
		return percent;
	}

	public void setPercent(Integer percent) {
		this.percent = percent;
	}

	@Override
    public String toString() {
        return "ReviewGenerationStatus{" +
                "upc=" + upc +
                ", status=" + status +
                ", startTime=" + startTime +
                ", endTime=" + endTime +
                ", result=" + result +
                ", errorMessage='" + errorMessage + '\'' +
                ", messages=" + messages +
                ", duration=" + duration +
                ", remaining=" + remaining +
                ", gtin='" + gtin + '\'' +
                '}';
    }

    @Override
    public int hashCode() {
        return Objects.hash(upc, status, startTime, endTime, result, errorMessage, messages, duration, remaining, gtin);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ReviewGenerationStatus)) return false;
        ReviewGenerationStatus that = (ReviewGenerationStatus) o;
        return upc == that.upc &&
                duration == that.duration &&
                remaining == that.remaining &&
                status == that.status &&
                Objects.equals(startTime, that.startTime) &&
                Objects.equals(endTime, that.endTime) &&
                Objects.equals(result, that.result) &&
                Objects.equals(errorMessage, that.errorMessage) &&
                Objects.equals(messages, that.messages) &&
                Objects.equals(gtin, that.gtin);
    }
}
~~~

## [ReviewRequest.java - /home/goulven/git/open4goods/services/review-generation/src/main/java/org/open4goods/services/reviewgeneration/dto/ReviewRequest.java]
~~~
package org.open4goods.services.reviewgeneration.dto;

import java.util.Objects;

import org.open4goods.model.product.Product;
import org.open4goods.model.vertical.VerticalConfig;

/**
 * DTO representing a review generation request.
 */
public class ReviewRequest {

    private Product product;
    
    /**
     * Vertical configuration (provided as an object; replace with a concrete type if available).
     */
    private VerticalConfig verticalConfig;

    // Getters and setters

    public Product getProduct() {
        return product;
    }

    public void setProduct(Product product) {
        this.product = product;
    }


    public VerticalConfig getVerticalConfig() {
		return verticalConfig;
	}

	public void setVerticalConfig(VerticalConfig verticalConfig) {
		this.verticalConfig = verticalConfig;
	}

	@Override
    public String toString() {
        return "ReviewRequest{" +
                "product=" + product +
                ", verticalConfig=" + verticalConfig +
                '}';
    }

    @Override
    public int hashCode() {
        return Objects.hash(product, verticalConfig);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ReviewRequest)) return false;
        ReviewRequest that = (ReviewRequest) o;
        return Objects.equals(product, that.product) &&
               Objects.equals(verticalConfig, that.verticalConfig);
    }
}
~~~

## [ReviewGenerationConfig.java - /home/goulven/git/open4goods/services/review-generation/src/main/java/org/open4goods/services/reviewgeneration/config/ReviewGenerationConfig.java]
~~~
package org.open4goods.services.reviewgeneration.config;

import java.util.ArrayList;
import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

/**
 * Configuration properties for the review generation service.
 */
@Configuration
@ConfigurationProperties(prefix = "review.generation")
public class ReviewGenerationConfig {

    private int threadPoolSize = 10;
    private int maxQueueSize = 100;  // Maximum size of the executor queue.
    private List<String> preferredDomains = new ArrayList<>();

    // Property used for building search queries.
    private String queryTemplate = "test %s \"%s\"";

    // Limit the number of search queries.
    private int maxSearch = 2;

    // Properties for token-based content aggregation.
    private int maxTotalTokens = 100000;
    private int sourceMinTokens = 150;
    private int sourceMaxTokens = 10000;

    // Maximum concurrent URL fetch operations.
    private int maxConcurrentFetch = 3;

    /**
     * The delay in months after which an existing AI review is considered outdated.
     * Default value is 6 months.
     */
    private int refreshDelayMonths = 6;

    /**
     * Estimated time for the review generation process.
     * Used to compute the remaining time.
     */
    private Long estimatedTime = 1000L * 60 * 2;

    // Getters and setters for existing properties.
    public int getThreadPoolSize() {
        return threadPoolSize;
    }
    public void setThreadPoolSize(int threadPoolSize) {
        this.threadPoolSize = threadPoolSize;
    }

    public int getMaxQueueSize() {
        return maxQueueSize;
    }
    public void setMaxQueueSize(int maxQueueSize) {
        this.maxQueueSize = maxQueueSize;
    }

    public List<String> getPreferredDomains() {
        return preferredDomains;
    }
    public void setPreferredDomains(List<String> preferredDomains) {
        this.preferredDomains = preferredDomains;
    }
    public String getQueryTemplate() {
        return queryTemplate;
    }
    public void setQueryTemplate(String queryTemplate) {
        this.queryTemplate = queryTemplate;
    }

    public int getMaxSearch() {
        return maxSearch;
    }
    public void setMaxSearch(int maxSearch) {
        this.maxSearch = maxSearch;
    }
    public int getMaxTotalTokens() {
        return maxTotalTokens;
    }
    public void setMaxTotalTokens(int maxTokensPerRequest) {
        this.maxTotalTokens = maxTokensPerRequest;
    }
    public int getSourceMinTokens() {
        return sourceMinTokens;
    }
    public void setSourceMinTokens(int minTokens) {
        this.sourceMinTokens = minTokens;
    }
    public int getMaxConcurrentFetch() {
        return maxConcurrentFetch;
    }
    public void setMaxConcurrentFetch(int maxConcurrentFetch) {
        this.maxConcurrentFetch = maxConcurrentFetch;
    }
    public int getSourceMaxTokens() {
        return sourceMaxTokens;
    }
    public void setSourceMaxTokens(int sourceMaxTokens) {
        this.sourceMaxTokens = sourceMaxTokens;
    }

    public int getRefreshDelayMonths() {
        return refreshDelayMonths;
    }
    public void setRefreshDelayMonths(int refreshDelayMonths) {
        this.refreshDelayMonths = refreshDelayMonths;
    }
    
    public Long getEstimatedTime() {
        return estimatedTime;
    }
    
    public void setEstimatedTime(Long estimatedTime) {
        this.estimatedTime = estimatedTime;
    }
}
~~~

## [application-test.yml - /home/goulven/git/open4goods/services/review-generation/src/test/resources/application-test.yml]
~~~
spring:
  ai:
    openai:
        api-key: sk-proj-FI9z9MAyJTarx13yZZNZuz66PL-ywf0hR1iX4e8sxa3aVoOtYfgOVnb3uUb84K-ugm9D-zhz5iT3BlbkFJZiHIaVGF8Z_qS-
        chat:
          api-key: sk-proj-FI9z9MAyJTarx13yZZNZuz66PL-ywf0hR1iX4e8sxa3aVoOtYfgOVnb3uUb84K-ugm9D-zhz5iT3BlbkFJZiHIaVGF8Z_qS-
            
gen-ai-config:
  cache-templates: true
  enabled: true
  prompts-templates-folder: src/test/resources/prompts
  
  ~~~

## [pom.xml - /home/goulven/git/open4goods/services/review-generation/pom.xml]
~~~
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>org.open4goods</groupId>
    <artifactId>org.open4goods</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  <artifactId>reviewgeneration</artifactId>
  
  
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

    

        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>model</artifactId>
            <version>${global.version}</version>
        </dependency>
        
        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>googlesearch</artifactId>
            <version>${global.version}</version>
        </dependency>

        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>product-repository</artifactId>
            <version>${global.version}</version>
        </dependency>

        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>googlesearch</artifactId>
            <version>${global.version}</version>
            <classifier>tests</classifier>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>urlfetching</artifactId>
            <version>${global.version}</version>
            <classifier>tests</classifier>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>prompt</artifactId>
            <version>${global.version}</version>
            <classifier>tests</classifier>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>urlfetching</artifactId>
            <version>${global.version}</version>
        </dependency>

        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>prompt</artifactId>
            <version>${global.version}</version>
        </dependency>


        <dependency>
        	<groupId>org.springframework.boot</groupId>
        	<artifactId>spring-boot-configuration-processor</artifactId>
        	<optional>true</optional>
        </dependency>
    </dependencies>
  
    <build>
    <plugins>
      <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-jar-plugin</artifactId>
      <version>3.4.2</version>
      <executions>
        <execution>
          <goals>
            <goal>test-jar</goal>
          </goals>
        </execution>
      </executions>
    </plugin>
      <!-- Maven Compiler Plugin -->
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <configuration>
          <source>${java.version}</source>
          <target>${java.version}</target>
        </configuration>
      </plugin>
      <!-- Spring Boot Maven Plugin -->
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>
</project>
~~~

## [pom.xml (pom parent) - /home/goulven/git/open4goods/pom.xml]
~~~
<project xmlns="http://maven.apache.org/POM/4.0.0"
		 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>org.open4goods</groupId>
	<artifactId>org.open4goods</artifactId>
	<name>parent</name>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>pom</packaging>
	<description>The open4goods project parent pom</description>
	<url>https://github.com/open4good/open4goods</url>
	<properties>
		<github.global.server>github</github.global.server>
		<springboot.version>3.4.3</springboot.version>
		<java.version>21</java.version>
		<maven.compiler.source>21</maven.compiler.source>
		<maven.compiler.target>21</maven.compiler.target>
		<global.version>0.0.1-SNAPSHOT</global.version>
		<swagger.version>2.9.2</swagger.version>
		<jacoco.version>0.8.12</jacoco.version>
		<xwiki.version>11.10.2</xwiki.version>

		<processDependencyManagement>false</processDependencyManagement>
		<processPluginDependenciesInPluginManagement>true</processPluginDependenciesInPluginManagement>
		<maven-compiler-plugin-version>3.14.0</maven-compiler-plugin-version>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>		
		<dependency.locations.enabled>false</dependency.locations.enabled>
		<exclude.tests>nothing-to-exclude</exclude.tests>
	</properties>

	<modules>
		<module>admin</module>
        <module>model</module>
		<module>commons</module>
		<module>verticals</module>
		<module>crawler</module>
		<module>api</module>
		<module>ui</module>
		<module>services/urlfetching</module>
        <module>services/googlesearch</module>
        <module>services/evaluation</module>
        <module>services/serialisation</module>
        <module>services/prompt</module>
        <module>services/review-generation</module>
        <module>services/product-repository</module>
        <module>services/captcha</module>
        <module>services/remotefilecaching</module>
        
        <module>services/favicon</module>
        
        
        
	</modules>

	<issueManagement>
		<url>https://github.com/open4good/open4goods/issues</url>
		<system>GitHub Issues</system>
	</issueManagement>

	<licenses>
		<license>
			<name>GNU AFFERO GENERAL PUBLIC LICENSE + Morality License</name>
			<url>
				https://raw.githubusercontent.com/open4good/open4goods/main/LICENSE</url>
			<distribution>repo</distribution>
		</license>
	</licenses>

	<scm>
		<url>https://github.com/open4good/open4goods</url>
		<connection>scm:git://github.com/open4good/open4goods</connection>
	</scm>


	<repositories>
		<repository>
			<id>central</id>
			<url>https://repo1.maven.org/maven2</url>
		</repository>

	</repositories>


	<distributionManagement>
		<site>
			<id>maven</id>
			<url>https://nudger.fr</url>
		</site>
	</distributionManagement>

	<dependencyManagement>
		<dependencies>
			<dependency>
				<!-- Import dependency management from Spring Boot -->
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-dependencies</artifactId>
				<version>${springboot.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>


	<dependencies>

		<!--
		<dependency>
		    <groupId>org.springframework.boot</groupId>
		    <artifactId>spring-boot-docker-compose</artifactId>
		</dependency>
-->


		<dependency>
			<groupId>net.sf.barcode4j</groupId>
			<artifactId>barcode4j</artifactId>
			<version>2.1</version>
		</dependency>

		<dependency>
			<groupId>com.sleepycat</groupId>
			<artifactId>je</artifactId>
			<version>18.3.12</version>
		</dependency>


		<dependency>
			<groupId>commons-io</groupId>
			<artifactId>commons-io</artifactId>
			<version>2.18.0</version>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>


		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-lang3</artifactId>
		</dependency>

		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-text</artifactId>
			<version>1.13.0</version>
		</dependency>

		<dependency>
			<groupId>ch.qos.logback</groupId>
			<artifactId>logback-classic</artifactId>
		</dependency>



		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<optional>true</optional>
		</dependency>
	</dependencies>


	<reporting>


		<plugins>

			<plugin>
				<groupId>org.jacoco</groupId>
				<artifactId>jacoco-maven-plugin</artifactId>
				<version>${jacoco.version}</version>

				<reportSets>
					<reportSet>
						<reports>
							<report>report</report>
						</reports>
					</reportSet>
				</reportSets>
			</plugin>

			<plugin>
				<groupId>org.codehaus.mojo</groupId>
				<artifactId>versions-maven-plugin</artifactId>
				<version>2.18.0</version>
				<reportSets>
					<reportSet>
						<reports>
							<report>dependency-updates-report</report>
							<report>plugin-updates-report</report>
							<report>property-updates-report</report>
						</reports>
					</reportSet>
				</reportSets>
			</plugin>


			<plugin>
				<groupId>org.codehaus.mojo</groupId>
				<artifactId>taglist-maven-plugin</artifactId>
				<version>3.2.1</version>
				<configuration>
					<aggregate>true</aggregate>
					<xmlOutputDirectory>${project.build.directory}/site/taglist</xmlOutputDirectory>

				</configuration>
				<reportSets>
					<reportSet>
						<!-- defines taglist reports in the modules -->
						<id>taglist-report</id>
						<reports>
							<report>taglist</report>
						</reports>
					</reportSet>

					<reportSet>
						<!-- defines taglist aggregate report -->
						<id>taglist-aggregate</id>
						<inherited>false</inherited>
						<reports>
							<report>taglist</report>
						</reports>
						<configuration>
							<aggregate>true</aggregate>
						</configuration>
					</reportSet>
				</reportSets>
			</plugin>


			<!-- Maven site plugin configuration -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-site-plugin</artifactId>
				<version>3.21.0</version>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-project-info-reports-plugin</artifactId>
				<version>3.9.0</version>
			</plugin>

		</plugins>

	</reporting>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-enforcer-plugin</artifactId>
				<version>3.5.0</version>
				<executions>
					<execution>
						<id>enforce-banned-dependencies</id>
						<goals>
							<goal>enforce</goal>
						</goals>
						<configuration>
							<rules>
								<bannedDependencies>
									<excludes>
										<!--this is to check we do not have the xml-apis included since
											JRE provides it already -->
										<exclude>xml-apis:xml-apis</exclude>

									</excludes>
								</bannedDependencies>
							</rules>
							<fail>true</fail>
						</configuration>
					</execution>
				</executions>
			</plugin>

			<!-- Jacoco plugin configuration -->
			<plugin>
				<groupId>org.jacoco</groupId>
				<artifactId>jacoco-maven-plugin</artifactId>
				<executions>
					<execution>
						<goals>
							<goal>prepare-agent</goal>
						</goals>
					</execution>
					<execution>
						<id>report</id>
						<phase>test</phase>
						<goals>
							<goal>report</goal>
						</goals>
					</execution>
				</executions>
			</plugin>


			<!-- Maven clean plugin configuration -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-clean-plugin</artifactId>
				<version>3.4.1</version>
				<configuration>
					<filesets>
						<fileset>
							<directory>logs</directory>
							<followSymlinks>false</followSymlinks>
						</fileset>
						<fileset>
							<directory>target</directory>
							<followSymlinks>false</followSymlinks>
						</fileset>
						<fileset>
							<directory>data</directory>
							<followSymlinks>false</followSymlinks>
						</fileset>
                        <fileset>
                            <directory>dist</directory>
                            <followSymlinks>false</followSymlinks>
                        </fileset>
                        <fileset>
                            <directory>node_modules</directory>
                            <followSymlinks>false</followSymlinks>
                        </fileset>
                        <fileset>
                            <directory>node_modules</directory>
                            <followSymlinks>false</followSymlinks>
                        </fileset>
                        
						<fileset>
							<directory>src/test/resources/last</directory>
							<followSymlinks>false</followSymlinks>
						</fileset>
					</filesets>
				</configuration>
			</plugin>


			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>3.5.2</version>
			</plugin>

			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-failsafe-plugin</artifactId>
				<version>3.5.2</version>
			</plugin>

			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-site-plugin</artifactId>
				<version>3.21.0</version>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-project-info-reports-plugin</artifactId>
				<version>3.9.0</version>
			</plugin>

		</plugins>

		<pluginManagement>
			<plugins>
				<!-- Maven compiler plugin configuration -->
				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-compiler-plugin</artifactId>
					<version>${maven-compiler-plugin-version}</version>
					<configuration>
						<release>21</release>
						<source>21</source>
						<target>21</target>
						<forceJavacCompilerUse>true</forceJavacCompilerUse>
						<parameters>true</parameters>
					</configuration>
				</plugin>

				<!-- Jacoco plugin configuration -->
				<plugin>
					<groupId>org.jacoco</groupId>
					<artifactId>jacoco-maven-plugin</artifactId>
					<version>${jacoco.version}</version>
				</plugin>
			</plugins>
		</pluginManagement>
	</build>
</project>~~~

