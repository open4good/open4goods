# Directory structure 
- pom.xml
- src
--- main
---- java
----- org
------ open4goods
------- services
-------- reviewgeneration
--------- config
---------- ReviewGenerationConfig.java
--------- dto
---------- ProcessStatus.java
---------- ReviewRequest.java
--------- service
---------- ReviewGenerationService.java
---- resources
----- META-INF
------ additional-spring-configuration-metadata.json
--- test
---- java
----- org
------ open4goods
------- reviewgeneration
-------- ReviewGenerationServiceTest.java
---- resources
----- application-test.yml

# Files content

## [ReviewGenerationService.java - /home/goulven/git/open4goods/services/reviewgeneration/src/main/java/org/open4goods/services/reviewgeneration/service/ReviewGenerationService.java]
~~~
package org.open4goods.services.reviewgeneration.service;

import java.net.URL;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.function.Predicate;

import org.open4goods.model.ai.AiReview;
import org.open4goods.model.product.Product;
import org.open4goods.model.vertical.VerticalConfig;
import org.open4goods.services.googlesearch.dto.GoogleSearchRequest;
import org.open4goods.services.googlesearch.dto.GoogleSearchResponse;
import org.open4goods.services.googlesearch.dto.GoogleSearchResult;
import org.open4goods.services.googlesearch.service.GoogleSearchService;
import org.open4goods.services.prompt.dto.PromptResponse;
import org.open4goods.services.prompt.service.PromptService;
import org.open4goods.services.reviewgeneration.config.ReviewGenerationConfig;
import org.open4goods.services.reviewgeneration.dto.ProcessStatus;
import org.open4goods.services.reviewgeneration.dto.ProcessStatus.Status;
import org.open4goods.services.urlfetching.dto.FetchResponse;
import org.open4goods.services.urlfetching.service.UrlFetchingService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Service;

import io.micrometer.core.instrument.MeterRegistry;

/**
 * Service for generating AI-assisted reviews.
 * <p>
 * This implementation has been refactored to use a new review generation logic:
 * <ol>
 *   <li>It builds search queries using the product’s brand and model (and alternate models) with a query template.
 *       A maximum of {@code maxSearch} queries are performed.</li>
 *   <li>All search results are then sorted so that URLs containing preferred domains (configured via {@code preferredDomains})
 *       appear first.</li>
 *   <li>Next, URLs are fetched concurrently (up to {@code maxConcurrentFetch} tasks in parallel).
 *       For each fetched URL, the PromptService.estimateTokens() method is used to count tokens.
 *       Only pages with at least {@code minTokens} tokens are accepted and pages are aggregated until the total tokens
 *       reach {@code maxTokensPerRequest}.</li>
 *   <li>Finally, the collected markdown contents are passed as prompt variables to generate the review.</li>
 * </ol>
 * <p>
 * The service supports both synchronous and asynchronous calls and tracks process status in memory.
 * It also implements HealthIndicator to report service health based on generation failures.
 */
@Service
public class ReviewGenerationService implements HealthIndicator {

    private static final Logger logger = LoggerFactory.getLogger(ReviewGenerationService.class);

    private final ReviewGenerationConfig properties;
    private final GoogleSearchService googleSearchService;
    private final UrlFetchingService urlFetchingService;
    private final PromptService genAiService;
    private final MeterRegistry meterRegistry;

    // Thread pool executor for asynchronous processing.
    private final ExecutorService executorService;

    // In-memory storage of process status keyed by UPC.
    private final ConcurrentMap<Long, ProcessStatus> processStatusMap = new ConcurrentHashMap<>();

    // Global metrics for review generations.
    private final AtomicInteger totalProcessed = new AtomicInteger(0);
    private final AtomicInteger successfulCount = new AtomicInteger(0);
    private final AtomicInteger failedCount = new AtomicInteger(0);

    // Flag used by the health check: set to true if any generation failed.
    private volatile boolean lastGenerationFailed = false;

    /**
     * Constructs a new ReviewGenerationService.
     *
     * @param properties the review generation configuration properties.
     * @param googleSearchService the Google search service.
     * @param urlFetchingService the URL fetching service.
     * @param genAiService the Gen AI service.
     * @param meterRegistry the actuator meter registry.
     */
    public ReviewGenerationService(ReviewGenerationConfig properties,
                                   GoogleSearchService googleSearchService,
                                   UrlFetchingService urlFetchingService,
                                   PromptService genAiService,
                                   MeterRegistry meterRegistry) {
        this.properties = properties;
        this.googleSearchService = googleSearchService;
        this.urlFetchingService = urlFetchingService;
        this.genAiService = genAiService;
        this.meterRegistry = meterRegistry;
        this.executorService = Executors.newFixedThreadPool(properties.getThreadPoolSize());
    }

    /**
     * Synchronously generates a review for the given product and vertical configuration.
     *
     * @param product the product containing brand, primary model, and alternate models.
     * @param verticalConfig the vertical configuration.
     * @return the generated review.
     */
    public AiReview generateReviewSync(Product product, VerticalConfig verticalConfig) {
        long upc = product.getId();
        ProcessStatus status = new ProcessStatus();
        status.setUpc(upc);
        status.setStatus(Status.PROCESSING);
        status.setStartTime(Instant.now());
        processStatusMap.put(upc, status);
        try {
            PromptResponse<AiReview> review = executeReviewGeneration(product, verticalConfig);
            status.setResult(review.getBody());
            status.setStatus(Status.SUCCESS);
            status.setEndTime(Instant.now());
            successfulCount.incrementAndGet();
            meterRegistry.counter("review.generation.success").increment();
            return review.getBody();
        } catch (Exception e) {
            logger.error("Review generation failed for UPC {}: {}", upc, e.getMessage(), e);
            status.setStatus(Status.FAILED);
            status.setErrorMessage(e.getMessage());
            status.setEndTime(Instant.now());
            failedCount.incrementAndGet();
            meterRegistry.counter("review.generation.failed").increment();
            lastGenerationFailed = true;
            throw new RuntimeException("Review generation failed", e);
        } finally {
            totalProcessed.incrementAndGet();
        }
    }

    /**
     * Asynchronously initiates review generation for the given product and vertical configuration.
     *
     * @param product the product containing brand, primary model, and alternate models.
     * @param verticalConfig the vertical configuration.
     * @return the process ID (UPC) used to track generation status.
     */
    public long generateReviewAsync(Product product, VerticalConfig verticalConfig) {
        long upc = product.getId();
        // Avoid duplicate runs on the same UPC if already processing.
        processStatusMap.compute(upc, (key, existingStatus) -> {
            if (existingStatus != null && existingStatus.getStatus() == Status.PROCESSING) {
                return existingStatus;
            } else {
                ProcessStatus status = new ProcessStatus();
                status.setUpc(upc);
                status.setStatus(Status.PENDING);
                status.setStartTime(Instant.now());
                return status;
            }
        });

        // Submit the review generation task asynchronously.
        executorService.submit(() -> {
            ProcessStatus status = processStatusMap.get(upc);
            status.setStatus(Status.PROCESSING);
            try {
                PromptResponse<AiReview> review = executeReviewGeneration(product, verticalConfig);
                status.setResult(review.getBody());
                status.setStatus(Status.SUCCESS);
                meterRegistry.counter("review.generation.success").increment();
            } catch (Exception e) {
                logger.error("Asynchronous review generation failed for UPC {}: {}", upc, e.getMessage(), e);
                status.setStatus(Status.FAILED);
                status.setErrorMessage(e.getMessage());
                meterRegistry.counter("review.generation.failed").increment();
                lastGenerationFailed = true;
            } finally {
                status.setEndTime(Instant.now());
                totalProcessed.incrementAndGet();
            }
        });
        return upc;
    }

    /**
     * Executes the review generation process using the new logic:
     * <ol>
     *   <li>Builds search queries using the product’s brand and primary model and then alternate models
     *       using the configured query template. A maximum of {@code maxSearch} queries are performed.</li>
     *   <li>Performs a Google search for each query and aggregates the search results.</li>
     *   <li>Deduplicates the search results to keep only one URL per distinct domain, and then sorts the results so that
     *       results from preferred domains appear first.</li>
     *   <li>Fetches the markdown content for each URL concurrently (up to {@code maxConcurrentFetch} tasks).
     *       For each fetched page, its token count is estimated via {@code PromptService.estimateTokens(String text)}.
     *       Pages with token counts below {@code minTokens} are discarded and pages are aggregated until
     *       the total token count reaches {@code maxTokensPerRequest}.</li>
     *   <li>Finally, the aggregated markdown content is passed as a prompt variable to generate the review.</li>
     * </ol>
     *
     * @param product the product.
     * @param verticalConfig the vertical configuration.
     * @return the generated review.
     * @throws Exception if an error occurs during generation.
     */
    private PromptResponse<AiReview> executeReviewGeneration(Product product, VerticalConfig verticalConfig) throws Exception {
        String brand = product.brand();
        String primaryModel = product.model();
        Set<String> alternateModels = product.getAkaModels();

        // Build a list of search queries using the configured query template.
        List<String> queries = new ArrayList<>();
        queries.add(String.format(properties.getQueryTemplate(), brand, primaryModel));
        if (alternateModels != null) {
            for (String akaModel : alternateModels) {
                queries.add(String.format(properties.getQueryTemplate(), brand, akaModel));
            }
        }

        // Perform searches up to the maximum allowed (maxSearch).
        int searchesMade = 0;
        List<GoogleSearchResult> allResults = new ArrayList<>();
        int maxSearch = properties.getMaxSearch();
        for (String query : queries) {
            if (searchesMade >= maxSearch) {
                break;
            }
            logger.debug("Executing search query: {}", query);
            //TODO(p3,i18N) : internationalisation from ReviewGenConfig
            GoogleSearchRequest searchRequest = new GoogleSearchRequest(query, "lang_fr", "countryFR");
            GoogleSearchResponse searchResponse = googleSearchService.search(searchRequest);
            searchesMade++;
            if (searchResponse != null && searchResponse.getResults() != null) {
                allResults.addAll(searchResponse.getResults());
            }
        }

        // Deduplicate and sort the search results:
        // 1. Keep only one URL per distinct domain.
        // 2. Sort so that entries from preferred domains come first.
        List<GoogleSearchResult> sortedResults = allResults.stream()
                .filter(r -> r.getLink() != null && !r.getLink().isEmpty())
                // excluding pdf
                .filter(r -> !r.getLink().endsWith(".pdf"))
                .filter(distinctByKey(r -> {
                    try {
                        return new URL(r.getLink()).getHost();
                    } catch (Exception e) {
                        return r.getLink();
                    }
                }))
                .sorted((r1, r2) -> {
                    boolean r1Preferred = properties.getPreferredDomains().stream()
                            .anyMatch(domain -> r1.getLink().contains(domain));
                    boolean r2Preferred = properties.getPreferredDomains().stream()
                            .anyMatch(domain -> r2.getLink().contains(domain));
                    if (r1Preferred && !r2Preferred) return -1;
                    if (!r1Preferred && r2Preferred) return 1;
                    return 0;
                })
                .toList();

        // Prepare to fetch URL content concurrently using a dedicated executor.
        ExecutorService fetchExecutor = Executors.newFixedThreadPool(properties.getMaxConcurrentFetch());
        Map<String, CompletableFuture<FetchResponse>> fetchFutures = new HashMap<>();
        for (GoogleSearchResult result : sortedResults) {
            String url = result.getLink();
            CompletableFuture<FetchResponse> future = CompletableFuture.supplyAsync(() -> {
                try {
                    return urlFetchingService.fetchUrl(url).get();
                } catch (Exception e) {
                    logger.warn("Failed to fetch content from URL {}: {}", url, e.getMessage());
                    return null;
                }
            }, fetchExecutor);
            fetchFutures.put(url, future);
        }
        fetchExecutor.shutdown();

        // Aggregate fetched markdown content until the maximum token limit is reached.
        int maxTotalTokens = properties.getMaxTotalTokens();
        int minTokens = properties.getSourceMinTokens();
        int maxTokens = properties.getMaxTotalTokens();
        
        int accumulatedTokens = 0;
        Map<String, String> finalSourcesMap = new LinkedHashMap<>();
        Map<String, Integer> finalTokensMap = new LinkedHashMap<>();
        
        // Process the sorted URLs in order.
        for (GoogleSearchResult result : sortedResults) {
            String url = result.getLink();
            CompletableFuture<FetchResponse> future = fetchFutures.get(url);
            if (future == null) continue;
            FetchResponse fetchResponse = future.get();
            if (fetchResponse == null || fetchResponse.markdownContent() == null || fetchResponse.markdownContent().isEmpty()) {
                continue;
            }
            String content = fetchResponse.markdownContent();
            int tokenCount = genAiService.estimateTokens(content);
            if (tokenCount < minTokens) {
                logger.warn("Content from URL {} discarded due to insufficient tokens: {}", url, tokenCount);
                continue;
            }
            if (tokenCount > maxTokens) {
                logger.warn("Content from URL {} discarded, exceed tokens limit: {}", url, tokenCount);
                continue;
            }
            
            
            if (accumulatedTokens + tokenCount > maxTotalTokens) {
                logger.warn("Reached max tokens threshold. Current tokens: {}, URL tokens: {}, threshold: {}",
                        accumulatedTokens, tokenCount, maxTotalTokens);
                break;
            }
            finalSourcesMap.put(url, content);
            finalTokensMap.put(url, genAiService.estimateTokens(content));
            accumulatedTokens += tokenCount;
        }
        logger.info("Aggregated {} tokens from {} sources.", accumulatedTokens, finalSourcesMap.size());

        // Compose the prompt variables including the collected markdown content.
        Map<String, Object> promptVariables = new HashMap<>();
        promptVariables.put("sources", finalSourcesMap);
        promptVariables.put("tokens", finalTokensMap);
        
        promptVariables.put("PRODUCT_NAME", product.shortestOfferName());
        promptVariables.put("PRODUCT_BRAND", product.brand());
        promptVariables.put("PRODUCT_MODEL", product.model());
        promptVariables.put("PRODUCT_GTIN", product.gtin());
        promptVariables.put("PRODUCT", product);
		
		
        promptVariables.put("VERTICAL_NAME", verticalConfig.i18n("fr").getH1Title().getPrefix());

		StringBuilder sb = new StringBuilder();
		verticalConfig.getAttributesConfig().getConfigs().forEach(attrConf -> {
			if (attrConf.getSynonyms().size()>0 ) {
				sb.append("        ").append("- ").append(attrConf.getKey()).append(" (").append(attrConf.getName().get("fr")).append(")").append("\n");				
			}
			
		});
		promptVariables.put("ATTRIBUTES", sb.toString());
		
        // Generate the review using the GenAiService with the prompt template "review-generation".
        return genAiService.objectPrompt("review-generation", promptVariables, AiReview.class);
    }

    /**
     * Returns the status of a review generation process by UPC.
     *
     * @param upc the UPC identifier.
     * @return the process status, or null if not found.
     */
    public ProcessStatus getProcessStatus(long upc) {
        return processStatusMap.get(upc);
    }

    /**
     * Returns global processing statistics.
     *
     * @return a map with keys: totalProcessed, successful, failed, and ongoing.
     */
    public Map<String, Integer> getGlobalStats() {
        Map<String, Integer> stats = new HashMap<>();
        stats.put("totalProcessed", totalProcessed.get());
        stats.put("successful", successfulCount.get());
        stats.put("failed", failedCount.get());
        // Count processes that are still PENDING or PROCESSING.
        long ongoing = processStatusMap.values().stream()
                .filter(s -> s.getStatus() == Status.PENDING || s.getStatus() == Status.PROCESSING)
                .count();
        stats.put("ongoing", (int) ongoing);
        return stats;
    }

    /**
     * Health check implementation.
     * <p>
     * The service is reported as DOWN if any review generation failure has occurred.
     *
     * @return Health status UP if healthy; otherwise DOWN with error details.
     */
    @Override
    public Health health() {
        if (lastGenerationFailed) {
            return Health.down().withDetail("error", "One or more review generations have failed").build();
        }
        return Health.up().build();
    }

    /**
     * Returns a predicate that maintains state about what keys have been seen so far, filtering out duplicates.
     *
     * @param keyExtractor a function to extract the key for comparison.
     * @param <T> the type of the input elements.
     * @return a predicate that returns true if the element is encountered for the first time.
     */
    private static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {
        Map<Object, Boolean> seen = new ConcurrentHashMap<>();
        return t -> seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
~~~

## [ReviewGenerationServiceTest.java - /home/goulven/git/open4goods/services/reviewgeneration/src/test/java/org/open4goods/reviewgeneration/ReviewGenerationServiceTest.java]
~~~
package org.open4goods.reviewgeneration;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.fail;

import java.util.Set;

import org.junit.jupiter.api.Test;
import org.open4goods.googlesearch.mock.GoogleSearchServiceMock;
import org.open4goods.model.ai.AiReview;
import org.open4goods.model.attribute.ReferentielKey;
import org.open4goods.model.product.Product;
import org.open4goods.model.vertical.PrefixedAttrText;
import org.open4goods.model.vertical.ProductI18nElements;
import org.open4goods.model.vertical.VerticalConfig;
import org.open4goods.services.prompt.service.mock.PromptServiceMock;
import org.open4goods.services.reviewgeneration.config.ReviewGenerationConfig;
import org.open4goods.services.reviewgeneration.dto.ProcessStatus;
import org.open4goods.services.reviewgeneration.service.ReviewGenerationService;
import org.open4goods.urlfetching.service.mock.UrlFetchingServiceMock;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.TestPropertySource;

@SpringBootTest(classes = {ReviewGenerationService.class, ReviewGenerationConfig.class, ReviewGenerationServiceTest.TestConfig.class})
@TestPropertySource(locations = "classpath:application-test.yml")
@ActiveProfiles("test")
@Import({GoogleSearchServiceMock.class, UrlFetchingServiceMock.class, PromptServiceMock.class})
public class ReviewGenerationServiceTest {

    /**
     * Minimal test configuration to bootstrap the Spring context.
     */
    @SpringBootConfiguration
    @EnableAutoConfiguration
    @ComponentScan(basePackages = {"org.open4goods.services"})
    public static class TestConfig {
        // This class remains empty; its purpose is to trigger component scanning.
    }

    @Autowired
    private ReviewGenerationService reviewGenerationService;

    @Test
    public void testGenerateReviewSync() {
        // Create a dummy product.
        Product product = new Product();
        product.setId(8806091548818L);
        product.getAttributes().getReferentielAttributes().put(ReferentielKey.BRAND, "LG");
        product.getAttributes().getReferentielAttributes().put(ReferentielKey.MODEL, "24TQ510S");
        product.setAkaModels(Set.of("24TQ510S-PZ.API", "24TQ510S-PZ"));

        // Dummy vertical configuration (as a String for testing).
        VerticalConfig verticalConfig = new VerticalConfig();
        verticalConfig.setId("tv");
        ProductI18nElements i18n = new ProductI18nElements();
        PrefixedAttrText p = new PrefixedAttrText();
        p.setPrefix("téléviseur");
        i18n.setH1Title(p);
        verticalConfig.getI18n().put("fr", i18n);

        // Invoke synchronous review generation.
        try {
            AiReview review = reviewGenerationService.generateReviewSync(product, verticalConfig);
            assertNotNull(review, "The generated review should not be null");
            System.out.println("Generated Review: " + review);
        } catch (Exception e) {
            fail("Review generation failed: ", e);
        }

        // Verify that the process status is SUCCESS.
        ProcessStatus status = reviewGenerationService.getProcessStatus(product.getId());
        assertNotNull(status, "Process status should be available");
        assertEquals(ProcessStatus.Status.SUCCESS, status.getStatus());
    }
    
    /**
     * New test case to verify that the URL content token thresholds and accumulation behave as expected.
     * <p>
     * This test simulates:
     * <ul>
     *   <li>A Google search returning two URLs.</li>
     *   <li>One URL returns content with an estimated token count above the minimum threshold.
     *       The other returns content with too few tokens.</li>
     *   <li>The aggregated tokens should include only the valid content and stop accumulation when reaching the maximum tokens limit.</li>
     * </ul>
     */
    @Test
    public void testGenerateReviewSyncTokenLimits() {
        // Create a dummy product.
        Product product = new Product();
        product.setId(1234567890123L);
        product.getAttributes().getReferentielAttributes().put(ReferentielKey.BRAND, "TestBrand");
        product.getAttributes().getReferentielAttributes().put(ReferentielKey.MODEL, "TestModel");
        // No alternate models for simplicity.
        
        // Dummy vertical configuration.
        VerticalConfig verticalConfig = new VerticalConfig();
        verticalConfig.setId("testVertical");
        ProductI18nElements i18n = new ProductI18nElements();
        PrefixedAttrText p = new PrefixedAttrText();
        p.setPrefix("TestVertical");
        i18n.setH1Title(p);
        verticalConfig.getI18n().put("fr", i18n);

        // The mocks (GoogleSearchServiceMock, UrlFetchingServiceMock, PromptServiceMock)
        // are assumed to be configured (or can be adjusted) so that:
        // - The search returns two URLs.
        // - The first URL returns content with an estimated token count of 150 (above a minTokens threshold of 100).
        // - The second URL returns content with an estimated token count of 50 (below minTokens).
        // - The ReviewGenerationConfig in application-test.yml is set for this test:
        //      review.generation.max-search=2
        //      review.generation.max-tokens-per-request=300
        //      review.generation.min-tokens=100
        //      review.generation.max-concurrent-fetch=3
        // - The prompt service returns a fixed review text.
        
        try {
            AiReview review = reviewGenerationService.generateReviewSync(product, verticalConfig);
            assertNotNull(review, "The generated review should not be null");
            System.out.println("Generated Review with token limits: " + review);
        } catch (Exception e) {
            fail("Review generation with token limits failed: ", e);
        }
    }
}
~~~

## [additional-spring-configuration-metadata.json - /home/goulven/git/open4goods/services/reviewgeneration/src/main/resources/META-INF/additional-spring-configuration-metadata.json]
~~~
{
  "groups": [
    {
      "name": "review.generation",
      "type": "org.open4goods.services.reviewgeneration.config.ReviewGenerationConfig",
      "sourceType": "org.open4goods.services.reviewgeneration.config.ReviewGenerationConfig"
    }
  ],
  "properties": [
    {
      "name": "review.generation.thread-pool-size",
      "type": "java.lang.Integer",
      "description": "Number of threads allocated for processing.",
      "defaultValue": 10
    },
    {
      "name": "review.generation.preferred-domains",
      "type": "java.util.List<java.lang.String>",
      "description": "List of preferred domains to fetch content from.",
      "defaultValue": []
    },
    {
      "name": "review.generation.query-template",
      "type": "java.lang.String",
      "description": "Template for constructing search queries.",
      "defaultValue": "test %s \"%s\""
    },
    {
      "name": "review.generation.max-search",
      "type": "java.lang.Integer",
      "description": "Maximum number of search queries allowed.",
      "defaultValue": 2
    },
    {
      "name": "review.generation.max-total-tokens",
      "type": "java.lang.Integer",
      "description": "Maximum total number of tokens allowed for aggregation.",
      "defaultValue": 100000
    },
    {
      "name": "review.generation.source-min-tokens",
      "type": "java.lang.Integer",
      "description": "Minimum number of tokens required for a source to be considered.",
      "defaultValue": 150
    },
    {
      "name": "review.generation.source-max-tokens",
      "type": "java.lang.Integer",
      "description": "Maximum number of tokens allowed per source.",
      "defaultValue": 10000
    },
    {
      "name": "review.generation.max-concurrent-fetch",
      "type": "java.lang.Integer",
      "description": "Maximum number of concurrent URL fetch operations.",
      "defaultValue": 3
    }
  ]
}
~~~

## [ProcessStatus.java - /home/goulven/git/open4goods/services/reviewgeneration/src/main/java/org/open4goods/services/reviewgeneration/dto/ProcessStatus.java]
~~~
package org.open4goods.services.reviewgeneration.dto;

import java.time.Instant;
import java.util.Objects;

import org.open4goods.model.ai.AiReview;

/**
 * DTO representing the status of a review generation process.
 */
public class ProcessStatus {

    /**
     * Possible states of a generation process.
     */
    public enum Status {
        PENDING, PROCESSING, SUCCESS, FAILED;
    }
    
    private long upc;
    private Status status;
    private Instant startTime;
    private Instant endTime;
    private AiReview result;
    private String errorMessage;

    // Getters and setters

    public long getUpc() {
        return upc;
    }

    public void setUpc(long upc) {
        this.upc = upc;
    }

    public Status getStatus() {
        return status;
    }

    public void setStatus(Status status) {
        this.status = status;
    }

    public Instant getStartTime() {
        return startTime;
    }

    public void setStartTime(Instant startTime) {
        this.startTime = startTime;
    }

    public Instant getEndTime() {
        return endTime;
    }

    public void setEndTime(Instant endTime) {
        this.endTime = endTime;
    }


    public AiReview getResult() {
		return result;
	}

	public void setResult(AiReview result) {
		this.result = result;
	}

	public String getErrorMessage() {
        return errorMessage;
    }

    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }

    // toString, equals, and hashCode

    @Override
    public String toString() {
        return "ProcessStatus{" +
                "upc=" + upc +
                ", status=" + status +
                ", startTime=" + startTime +
                ", endTime=" + endTime +
                ", result='" + result + '\'' +
                ", errorMessage='" + errorMessage + '\'' +
                '}';
    }

    @Override
    public int hashCode() {
        return Objects.hash(upc, status, startTime, endTime, result, errorMessage);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ProcessStatus)) return false;
        ProcessStatus that = (ProcessStatus) o;
        return upc == that.upc &&
                status == that.status &&
                Objects.equals(startTime, that.startTime) &&
                Objects.equals(endTime, that.endTime) &&
                Objects.equals(result, that.result) &&
                Objects.equals(errorMessage, that.errorMessage);
    }
}
~~~

## [ReviewRequest.java - /home/goulven/git/open4goods/services/reviewgeneration/src/main/java/org/open4goods/services/reviewgeneration/dto/ReviewRequest.java]
~~~
package org.open4goods.services.reviewgeneration.dto;

import java.util.Objects;

import org.open4goods.model.product.Product;
import org.open4goods.model.vertical.VerticalConfig;

/**
 * DTO representing a review generation request.
 */
public class ReviewRequest {

    private Product product;
    
    /**
     * Vertical configuration (provided as an object; replace with a concrete type if available).
     */
    private VerticalConfig verticalConfig;

    // Getters and setters

    public Product getProduct() {
        return product;
    }

    public void setProduct(Product product) {
        this.product = product;
    }


    public VerticalConfig getVerticalConfig() {
		return verticalConfig;
	}

	public void setVerticalConfig(VerticalConfig verticalConfig) {
		this.verticalConfig = verticalConfig;
	}

	@Override
    public String toString() {
        return "ReviewRequest{" +
                "product=" + product +
                ", verticalConfig=" + verticalConfig +
                '}';
    }

    @Override
    public int hashCode() {
        return Objects.hash(product, verticalConfig);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ReviewRequest)) return false;
        ReviewRequest that = (ReviewRequest) o;
        return Objects.equals(product, that.product) &&
               Objects.equals(verticalConfig, that.verticalConfig);
    }
}
~~~

## [ReviewGenerationConfig.java - /home/goulven/git/open4goods/services/reviewgeneration/src/main/java/org/open4goods/services/reviewgeneration/config/ReviewGenerationConfig.java]
~~~
package org.open4goods.services.reviewgeneration.config;

import java.util.ArrayList;
import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

/**
 * Configuration properties for the review generation service.
 */
@Configuration
@ConfigurationProperties(prefix = "review.generation")
public class ReviewGenerationConfig {

    private int threadPoolSize = 10;

    private List<String> preferredDomains = new ArrayList<>();

    // Existing property used for building search queries.
    private String queryTemplate = "test %s \"%s\"";

    // Retained property to limit the number of search queries.
    private int maxSearch = 2;

    // New properties for token-based content aggregation.
    private int maxTotalTokens = 100000;
    private int sourceMinTokens = 150;
    private int sourceMaxTokens = 10000;

    // New property: maximum concurrent URL fetch operations.
    private int maxConcurrentFetch = 3;

    // Getters and setters for existing properties.
    public int getThreadPoolSize() {
        return threadPoolSize;
    }
    public void setThreadPoolSize(int threadPoolSize) {
        this.threadPoolSize = threadPoolSize;
    }
    public List<String> getPreferredDomains() {
        return preferredDomains;
    }
    public void setPreferredDomains(List<String> preferredDomains) {
        this.preferredDomains = preferredDomains;
    }
    public String getQueryTemplate() {
        return queryTemplate;
    }
    public void setQueryTemplate(String queryTemplate) {
        this.queryTemplate = queryTemplate;
    }

    // Getters and setters for new properties.
    public int getMaxSearch() {
        return maxSearch;
    }
    public void setMaxSearch(int maxSearch) {
        this.maxSearch = maxSearch;
    }
    public int getMaxTotalTokens() {
        return maxTotalTokens;
    }
    public void setMaxTotalTokens(int maxTokensPerRequest) {
        this.maxTotalTokens = maxTokensPerRequest;
    }
    public int getSourceMinTokens() {
        return sourceMinTokens;
    }
    public void setSourceMinTokens(int minTokens) {
        this.sourceMinTokens = minTokens;
    }
    public int getMaxConcurrentFetch() {
        return maxConcurrentFetch;
    }
    public void setMaxConcurrentFetch(int maxConcurrentFetch) {
        this.maxConcurrentFetch = maxConcurrentFetch;
    }
	public int getSourceMaxTokens() {
		return sourceMaxTokens;
	}
	public void setSourceMaxTokens(int sourceMaxTokens) {
		this.sourceMaxTokens = sourceMaxTokens;
	}
    
    
}
~~~

## [application-test.yml - /home/goulven/git/open4goods/services/reviewgeneration/src/test/resources/application-test.yml]
~~~
spring:
  ai:
    openai:
        api-key: sk-proj-FI9z9MAyJTarx13yZZNZuz66PL-ywf0hR1iX4e8sxa3aVoOtYfgOVnb3uUb84K-ugm9D-zhz5iT3BlbkFJZiHIaVGF8Z_qS-
        chat:
          api-key: sk-proj-FI9z9MAyJTarx13yZZNZuz66PL-ywf0hR1iX4e8sxa3aVoOtYfgOVnb3uUb84K-ugm9D-zhz5iT3BlbkFJZiHIaVGF8Z_qS-
            
gen-ai-config:
  cache-templates: true
  enabled: true
  prompts-templates-folder: src/test/resources/prompts
  
  ~~~

## [pom.xml - /home/goulven/git/open4goods/services/reviewgeneration/pom.xml]
~~~
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>org.open4goods</groupId>
    <artifactId>org.open4goods</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  <artifactId>reviewgeneration</artifactId>
  
  
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

    

        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>model</artifactId>
            <version>${global.version}</version>
        </dependency>
        
        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>googlesearch</artifactId>
            <version>${global.version}</version>
        </dependency>

        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>googlesearch</artifactId>
            <version>${global.version}</version>
            <classifier>tests</classifier>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>urlfetching</artifactId>
            <version>${global.version}</version>
            <classifier>tests</classifier>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>prompt</artifactId>
            <version>${global.version}</version>
            <classifier>tests</classifier>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>urlfetching</artifactId>
            <version>${global.version}</version>
        </dependency>

        <dependency>
            <groupId>org.open4goods</groupId>
            <artifactId>prompt</artifactId>
            <version>${global.version}</version>
        </dependency>


        <dependency>
        	<groupId>org.springframework.boot</groupId>
        	<artifactId>spring-boot-configuration-processor</artifactId>
        	<optional>true</optional>
        </dependency>
    </dependencies>
  
    <build>
    <plugins>
      <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-jar-plugin</artifactId>
      <version>3.4.2</version>
      <executions>
        <execution>
          <goals>
            <goal>test-jar</goal>
          </goals>
        </execution>
      </executions>
    </plugin>
      <!-- Maven Compiler Plugin -->
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <configuration>
          <source>${java.version}</source>
          <target>${java.version}</target>
        </configuration>
      </plugin>
      <!-- Spring Boot Maven Plugin -->
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>
</project>
~~~

## [pom.xml (pom parent) - /home/goulven/git/open4goods/pom.xml]
~~~
<project xmlns="http://maven.apache.org/POM/4.0.0"
		 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>org.open4goods</groupId>
	<artifactId>org.open4goods</artifactId>
	<name>parent</name>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>pom</packaging>
	<description>The open4goods project parent pom</description>
	<url>https://github.com/open4good/open4goods</url>
	<properties>
		<github.global.server>github</github.global.server>
		<springboot.version>3.4.3</springboot.version>
		<java.version>21</java.version>
		<maven.compiler.source>21</maven.compiler.source>
		<maven.compiler.target>21</maven.compiler.target>
		<global.version>0.0.1-SNAPSHOT</global.version>
		<swagger.version>2.9.2</swagger.version>
		<jacoco.version>0.8.12</jacoco.version>
		<xwiki.version>11.10.2</xwiki.version>

		<processDependencyManagement>false</processDependencyManagement>
		<processPluginDependenciesInPluginManagement>true</processPluginDependenciesInPluginManagement>
		<maven-compiler-plugin-version>3.14.0</maven-compiler-plugin-version>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>		
		<dependency.locations.enabled>false</dependency.locations.enabled>
		<exclude.tests>nothing-to-exclude</exclude.tests>
	</properties>

	<modules>
		<module>admin</module>
        <module>model</module>
		<module>commons</module>
		<module>verticals</module>
		<module>crawler</module>
		<module>api</module>
		<module>ui</module>
		<module>services/urlfetching</module>
        <module>services/googlesearch</module>
        <module>services/evaluation</module>
        <module>services/serialisation</module>
        <module>services/prompt</module>
        <module>services/reviewgeneration</module>
        
        
	</modules>

	<issueManagement>
		<url>https://github.com/open4good/open4goods/issues</url>
		<system>GitHub Issues</system>
	</issueManagement>

	<licenses>
		<license>
			<name>GNU AFFERO GENERAL PUBLIC LICENSE + Morality License</name>
			<url>
				https://raw.githubusercontent.com/open4good/open4goods/main/LICENSE</url>
			<distribution>repo</distribution>
		</license>
	</licenses>

	<scm>
		<url>https://github.com/open4good/open4goods</url>
		<connection>scm:git://github.com/open4good/open4goods</connection>
	</scm>


	<repositories>
		<repository>
			<id>central</id>
			<url>https://repo1.maven.org/maven2</url>
		</repository>

	</repositories>


	<distributionManagement>
		<site>
			<id>maven</id>
			<url>https://nudger.fr</url>
		</site>
	</distributionManagement>

	<dependencyManagement>
		<dependencies>
			<dependency>
				<!-- Import dependency management from Spring Boot -->
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-dependencies</artifactId>
				<version>${springboot.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>


	<dependencies>

		<!--
		<dependency>
		    <groupId>org.springframework.boot</groupId>
		    <artifactId>spring-boot-docker-compose</artifactId>
		</dependency>
-->


		<dependency>
			<groupId>net.sf.barcode4j</groupId>
			<artifactId>barcode4j</artifactId>
			<version>2.1</version>
		</dependency>

		<dependency>
			<groupId>com.sleepycat</groupId>
			<artifactId>je</artifactId>
			<version>18.3.12</version>
		</dependency>


		<dependency>
			<groupId>commons-io</groupId>
			<artifactId>commons-io</artifactId>
			<version>2.18.0</version>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>


		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-lang3</artifactId>
		</dependency>

		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-text</artifactId>
			<version>1.13.0</version>
		</dependency>

		<dependency>
			<groupId>ch.qos.logback</groupId>
			<artifactId>logback-classic</artifactId>
		</dependency>



		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<optional>true</optional>
		</dependency>
	</dependencies>


	<reporting>


		<plugins>

			<plugin>
				<groupId>org.jacoco</groupId>
				<artifactId>jacoco-maven-plugin</artifactId>
				<version>${jacoco.version}</version>

				<reportSets>
					<reportSet>
						<reports>
							<report>report</report>
						</reports>
					</reportSet>
				</reportSets>
			</plugin>

			<plugin>
				<groupId>org.codehaus.mojo</groupId>
				<artifactId>versions-maven-plugin</artifactId>
				<version>2.18.0</version>
				<reportSets>
					<reportSet>
						<reports>
							<report>dependency-updates-report</report>
							<report>plugin-updates-report</report>
							<report>property-updates-report</report>
						</reports>
					</reportSet>
				</reportSets>
			</plugin>


			<plugin>
				<groupId>org.codehaus.mojo</groupId>
				<artifactId>taglist-maven-plugin</artifactId>
				<version>3.2.1</version>
				<configuration>
					<aggregate>true</aggregate>
					<xmlOutputDirectory>${project.build.directory}/site/taglist</xmlOutputDirectory>

				</configuration>
				<reportSets>
					<reportSet>
						<!-- defines taglist reports in the modules -->
						<id>taglist-report</id>
						<reports>
							<report>taglist</report>
						</reports>
					</reportSet>

					<reportSet>
						<!-- defines taglist aggregate report -->
						<id>taglist-aggregate</id>
						<inherited>false</inherited>
						<reports>
							<report>taglist</report>
						</reports>
						<configuration>
							<aggregate>true</aggregate>
						</configuration>
					</reportSet>
				</reportSets>
			</plugin>


			<!-- Maven site plugin configuration -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-site-plugin</artifactId>
				<version>3.21.0</version>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-project-info-reports-plugin</artifactId>
				<version>3.9.0</version>
			</plugin>

		</plugins>

	</reporting>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-enforcer-plugin</artifactId>
				<version>3.5.0</version>
				<executions>
					<execution>
						<id>enforce-banned-dependencies</id>
						<goals>
							<goal>enforce</goal>
						</goals>
						<configuration>
							<rules>
								<bannedDependencies>
									<excludes>
										<!--this is to check we do not have the xml-apis included since
											JRE provides it already -->
										<exclude>xml-apis:xml-apis</exclude>

									</excludes>
								</bannedDependencies>
							</rules>
							<fail>true</fail>
						</configuration>
					</execution>
				</executions>
			</plugin>

			<!-- Jacoco plugin configuration -->
			<plugin>
				<groupId>org.jacoco</groupId>
				<artifactId>jacoco-maven-plugin</artifactId>
				<executions>
					<execution>
						<goals>
							<goal>prepare-agent</goal>
						</goals>
					</execution>
					<execution>
						<id>report</id>
						<phase>test</phase>
						<goals>
							<goal>report</goal>
						</goals>
					</execution>
				</executions>
			</plugin>


			<!-- Maven clean plugin configuration -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-clean-plugin</artifactId>
				<version>3.4.1</version>
				<configuration>
					<filesets>
						<fileset>
							<directory>logs</directory>
							<followSymlinks>false</followSymlinks>
						</fileset>
						<fileset>
							<directory>target</directory>
							<followSymlinks>false</followSymlinks>
						</fileset>
						<fileset>
							<directory>data</directory>
							<followSymlinks>false</followSymlinks>
						</fileset>
                        <fileset>
                            <directory>dist</directory>
                            <followSymlinks>false</followSymlinks>
                        </fileset>
                        <fileset>
                            <directory>node_modules</directory>
                            <followSymlinks>false</followSymlinks>
                        </fileset>
                        <fileset>
                            <directory>node_modules</directory>
                            <followSymlinks>false</followSymlinks>
                        </fileset>
                        
						<fileset>
							<directory>src/test/resources/last</directory>
							<followSymlinks>false</followSymlinks>
						</fileset>
					</filesets>
				</configuration>
			</plugin>


			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>3.5.2</version>
			</plugin>

			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-failsafe-plugin</artifactId>
				<version>3.5.2</version>
			</plugin>

			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-site-plugin</artifactId>
				<version>3.21.0</version>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-project-info-reports-plugin</artifactId>
				<version>3.9.0</version>
			</plugin>

		</plugins>

		<pluginManagement>
			<plugins>
				<!-- Maven compiler plugin configuration -->
				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-compiler-plugin</artifactId>
					<version>${maven-compiler-plugin-version}</version>
					<configuration>
						<release>21</release>
						<source>21</source>
						<target>21</target>
						<forceJavacCompilerUse>true</forceJavacCompilerUse>
						<parameters>true</parameters>
					</configuration>
				</plugin>

				<!-- Jacoco plugin configuration -->
				<plugin>
					<groupId>org.jacoco</groupId>
					<artifactId>jacoco-maven-plugin</artifactId>
					<version>${jacoco.version}</version>
				</plugin>
			</plugins>
		</pluginManagement>
	</build>
</project>~~~

