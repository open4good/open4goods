/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI
 * OpenAPI
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Agg
 */
export interface Agg {
    /**
     * Aggregation name
     * @type {string}
     * @memberof Agg
     */
    'name'?: string;
    /**
     * Field to aggregate
     * @type {string}
     * @memberof Agg
     */
    'field'?: AggFieldEnum;
    /**
     * Aggregation type
     * @type {string}
     * @memberof Agg
     */
    'type'?: AggTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof Agg
     */
    'subAgg'?: any;
    /**
     * Minimum value for range aggregations
     * @type {number}
     * @memberof Agg
     */
    'min'?: number;
    /**
     * Maximum value for range aggregations
     * @type {number}
     * @memberof Agg
     */
    'max'?: number;
}

export const AggFieldEnum = {
    PriceMinPricePrice: 'price.minPrice.price',
    OffersCount: 'offersCount'
} as const;

export type AggFieldEnum = typeof AggFieldEnum[keyof typeof AggFieldEnum];
export const AggTypeEnum = {
    Terms: 'terms',
    Range: 'range'
} as const;

export type AggTypeEnum = typeof AggTypeEnum[keyof typeof AggTypeEnum];

/**
 * 
 * @export
 * @interface AggregationRequestDto
 */
export interface AggregationRequestDto {
    /**
     * List of aggregations to compute
     * @type {Array<Agg>}
     * @memberof AggregationRequestDto
     */
    'aggs'?: Array<Agg>;
}
/**
 * 
 * @export
 * @interface AiAttribute
 */
export interface AiAttribute {
    /**
     * 
     * @type {string}
     * @memberof AiAttribute
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AiAttribute
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof AiAttribute
     */
    'number': number;
}
/**
 * 
 * @export
 * @interface AiReview
 */
export interface AiReview {
    /**
     * 
     * @type {string}
     * @memberof AiReview
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof AiReview
     */
    'short_description': string;
    /**
     * 
     * @type {string}
     * @memberof AiReview
     */
    'mediumTitle': string;
    /**
     * 
     * @type {string}
     * @memberof AiReview
     */
    'shortTitle': string;
    /**
     * 
     * @type {string}
     * @memberof AiReview
     */
    'technicalReview': string;
    /**
     * 
     * @type {string}
     * @memberof AiReview
     */
    'ecologicalReview': string;
    /**
     * 
     * @type {string}
     * @memberof AiReview
     */
    'summary': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AiReview
     */
    'pros': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AiReview
     */
    'cons': Array<string>;
    /**
     * 
     * @type {Array<AiSource>}
     * @memberof AiReview
     */
    'sources': Array<AiSource>;
    /**
     * 
     * @type {Array<AiAttribute>}
     * @memberof AiReview
     */
    'attributes': Array<AiAttribute>;
    /**
     * 
     * @type {string}
     * @memberof AiReview
     */
    'dataQuality': string;
}
/**
 * 
 * @export
 * @interface AiSource
 */
export interface AiSource {
    /**
     * 
     * @type {number}
     * @memberof AiSource
     */
    'number': number;
    /**
     * 
     * @type {string}
     * @memberof AiSource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AiSource
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof AiSource
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * 
     * @type {Array<Link>}
     * @memberof Attachment
     */
    'links'?: Array<Link>;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'longSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'pageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'pageVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'mimeType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'authorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'xwikiRelativeUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'xwikiAbsoluteUrl'?: string;
    /**
     * 
     * @type {Hierarchy}
     * @memberof Attachment
     */
    'hierarchy'?: Hierarchy;
}
/**
 * 
 * @export
 * @interface Attachments
 */
export interface Attachments {
    /**
     * 
     * @type {Array<Link>}
     * @memberof Attachments
     */
    'links'?: Array<Link>;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof Attachments
     */
    'attachments'?: Array<Attachment>;
}
/**
 * 
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * 
     * @type {Array<Link>}
     * @memberof Attribute
     */
    'links'?: Array<Link>;
    /**
     * 
     * @type {string}
     * @memberof Attribute
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attribute
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BlogPostDto
 */
export interface BlogPostDto {
    /**
     * URL slug identifying the post
     * @type {string}
     * @memberof BlogPostDto
     */
    'url'?: string;
    /**
     * Post title
     * @type {string}
     * @memberof BlogPostDto
     */
    'title'?: string;
    /**
     * Author full name
     * @type {string}
     * @memberof BlogPostDto
     */
    'author'?: string;
    /**
     * Post summary
     * @type {string}
     * @memberof BlogPostDto
     */
    'summary'?: string;
    /**
     * HTML body
     * @type {string}
     * @memberof BlogPostDto
     */
    'body'?: string;
    /**
     * Post categories
     * @type {Array<string>}
     * @memberof BlogPostDto
     */
    'category'?: Array<string>;
    /**
     * Cover image URL
     * @type {string}
     * @memberof BlogPostDto
     */
    'image'?: string;
    /**
     * Direct edit link
     * @type {string}
     * @memberof BlogPostDto
     */
    'editLink'?: string;
    /**
     * Creation timestamp ms
     * @type {number}
     * @memberof BlogPostDto
     */
    'createdMs'?: number;
    /**
     * Modification timestamp ms
     * @type {number}
     * @memberof BlogPostDto
     */
    'modifiedMs'?: number;
}
/**
 * 
 * @export
 * @interface BlogTagDto
 */
export interface BlogTagDto {
    /**
     * Tag name
     * @type {string}
     * @memberof BlogTagDto
     */
    'name'?: string;
    /**
     * Number of posts having this tag
     * @type {number}
     * @memberof BlogTagDto
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface Class
 */
export interface Class {
    /**
     * 
     * @type {Array<Link>}
     * @memberof Class
     */
    'links'?: Array<Link>;
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Property>}
     * @memberof Class
     */
    'properties'?: Array<Property>;
}
/**
 * 
 * @export
 * @interface ExternalIds
 */
export interface ExternalIds {
    /**
     * 
     * @type {string}
     * @memberof ExternalIds
     */
    'asin'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalIds
     */
    'icecat'?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof ExternalIds
     */
    'mpn'?: Set<string>;
    /**
     * 
     * @type {Set<string>}
     * @memberof ExternalIds
     */
    'sku'?: Set<string>;
}
/**
 * 
 * @export
 * @interface FullPage
 */
export interface FullPage {
    /**
     * 
     * @type {string}
     * @memberof FullPage
     */
    'htmlContent'?: string;
    /**
     * 
     * @type {Page}
     * @memberof FullPage
     */
    'wikiPage'?: Page;
    /**
     * 
     * @type {Objects}
     * @memberof FullPage
     */
    'objects'?: Objects;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FullPage
     */
    'properties'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Hierarchy
 */
export interface Hierarchy {
    /**
     * 
     * @type {Array<HierarchyItem>}
     * @memberof Hierarchy
     */
    'items'?: Array<HierarchyItem>;
}
/**
 * 
 * @export
 * @interface HierarchyItem
 */
export interface HierarchyItem {
    /**
     * 
     * @type {string}
     * @memberof HierarchyItem
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof HierarchyItem
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HierarchyItem
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof HierarchyItem
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'rel'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'hrefLang'?: string;
}
/**
 * 
 * @export
 * @interface ObjectSummary
 */
export interface ObjectSummary {
    /**
     * 
     * @type {Array<Link>}
     * @memberof ObjectSummary
     */
    'links'?: Array<Link>;
    /**
     * 
     * @type {string}
     * @memberof ObjectSummary
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectSummary
     */
    'guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectSummary
     */
    'pageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectSummary
     */
    'pageVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectSummary
     */
    'wiki'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectSummary
     */
    'space'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectSummary
     */
    'pageName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectSummary
     */
    'pageAuthor'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectSummary
     */
    'pageAuthorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectSummary
     */
    'className'?: string;
    /**
     * 
     * @type {number}
     * @memberof ObjectSummary
     */
    'number'?: number;
    /**
     * 
     * @type {string}
     * @memberof ObjectSummary
     */
    'headline'?: string;
}
/**
 * 
 * @export
 * @interface Objects
 */
export interface Objects {
    /**
     * 
     * @type {Array<Link>}
     * @memberof Objects
     */
    'links'?: Array<Link>;
    /**
     * 
     * @type {Array<ObjectSummary>}
     * @memberof Objects
     */
    'objectSummaries'?: Array<ObjectSummary>;
}
/**
 * 
 * @export
 * @interface Page
 */
export interface Page {
    /**
     * 
     * @type {Array<Link>}
     * @memberof Page
     */
    'links'?: Array<Link>;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'wiki'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'space'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'rawTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'parent'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'parentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'authorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'xwikiRelativeUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'xwikiAbsoluteUrl'?: string;
    /**
     * 
     * @type {Translations}
     * @memberof Page
     */
    'translations'?: Translations;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'syntax'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'language'?: string;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'majorVersion'?: number;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'minorVersion'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Page
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'creator'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'creatorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'modifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'modifierName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'originalMetadataAuthor'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'originalMetadataAuthorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'content'?: string;
    /**
     * 
     * @type {Class}
     * @memberof Page
     */
    'clazz'?: Class;
    /**
     * 
     * @type {Objects}
     * @memberof Page
     */
    'objects'?: Objects;
    /**
     * 
     * @type {Attachments}
     * @memberof Page
     */
    'attachments'?: Attachments;
    /**
     * 
     * @type {Hierarchy}
     * @memberof Page
     */
    'hierarchy'?: Hierarchy;
}
/**
 * 
 * @export
 * @interface PageDto
 */
export interface PageDto {
    /**
     * Pagination metadata
     * @type {PageMetaDto}
     * @memberof PageDto
     */
    'page'?: PageMetaDto;
    /**
     * Current page content
     * @type {Array<any>}
     * @memberof PageDto
     */
    'data'?: Array<any>;
}
/**
 * 
 * @export
 * @interface PageMetaDto
 */
export interface PageMetaDto {
    /**
     * Zero-based page index
     * @type {number}
     * @memberof PageMetaDto
     */
    'number'?: number;
    /**
     * Requested page size
     * @type {number}
     * @memberof PageMetaDto
     */
    'size'?: number;
    /**
     * Total number of elements
     * @type {number}
     * @memberof PageMetaDto
     */
    'totalElements'?: number;
    /**
     * Total number of pages
     * @type {number}
     * @memberof PageMetaDto
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface PageProductDto
 */
export interface PageProductDto {
    /**
     * 
     * @type {number}
     * @memberof PageProductDto
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageProductDto
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageProductDto
     */
    'size'?: number;
    /**
     * 
     * @type {Array<ProductDto>}
     * @memberof PageProductDto
     */
    'content'?: Array<ProductDto>;
    /**
     * 
     * @type {number}
     * @memberof PageProductDto
     */
    'number'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof PageProductDto
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {boolean}
     * @memberof PageProductDto
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageProductDto
     */
    'last'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageProductDto
     */
    'numberOfElements'?: number;
    /**
     * 
     * @type {PageableObject}
     * @memberof PageProductDto
     */
    'pageable'?: PageableObject;
    /**
     * 
     * @type {boolean}
     * @memberof PageProductDto
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface PageableObject
 */
export interface PageableObject {
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'offset'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof PageableObject
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {boolean}
     * @memberof PageableObject
     */
    'paged'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'pageSize'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageableObject
     */
    'unpaged'?: boolean;
}
/**
 * 
 * @export
 * @interface ProductAiReviewDto
 */
export interface ProductAiReviewDto {
    /**
     * 
     * @type {AiReview}
     * @memberof ProductAiReviewDto
     */
    'review'?: AiReview;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ProductAiReviewDto
     */
    'sources'?: { [key: string]: number; };
    /**
     * 
     * @type {boolean}
     * @memberof ProductAiReviewDto
     */
    'enoughData'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductAiReviewDto
     */
    'totalTokens'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductAiReviewDto
     */
    'createdMs'?: number;
}
/**
 * 
 * @export
 * @interface ProductAiTextsDto
 */
export interface ProductAiTextsDto {
    /**
     * AI description
     * @type {string}
     * @memberof ProductAiTextsDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ProductBaseDto
 */
export interface ProductBaseDto {
    /**
     * Product GTIN
     * @type {number}
     * @memberof ProductBaseDto
     */
    'gtin'?: number;
    /**
     * Creation timestamp
     * @type {number}
     * @memberof ProductBaseDto
     */
    'creationDate'?: number;
    /**
     * Last change timestamp
     * @type {number}
     * @memberof ProductBaseDto
     */
    'lastChange'?: number;
    /**
     * Associated vertical
     * @type {string}
     * @memberof ProductBaseDto
     */
    'vertical'?: string;
    /**
     * External identifiers
     * @type {ExternalIds}
     * @memberof ProductBaseDto
     */
    'externalIds'?: ExternalIds;
    /**
     * Google taxonomy identifier
     * @type {number}
     * @memberof ProductBaseDto
     */
    'googleTaxonomyId'?: number;
}
/**
 * 
 * @export
 * @interface ProductDto
 */
export interface ProductDto {
    /**
     * Product GTIN, it is the unique identifier
     * @type {number}
     * @memberof ProductDto
     */
    'gtin'?: number;
    /**
     * Basic product metadata
     * @type {ProductBaseDto}
     * @memberof ProductDto
     */
    'base'?: ProductBaseDto;
    /**
     * Localised textual information
     * @type {ProductNamesDto}
     * @memberof ProductDto
     */
    'names'?: ProductNamesDto;
    /**
     * Associated media resources
     * @type {ProductResourcesDto}
     * @memberof ProductDto
     */
    'resources'?: ProductResourcesDto;
    /**
     * AI generated texts
     * @type {ProductAiTextsDto}
     * @memberof ProductDto
     */
    'aiTexts'?: ProductAiTextsDto;
    /**
     * AI-generated review
     * @type {ProductAiReviewDto}
     * @memberof ProductDto
     */
    'aiReview'?: ProductAiReviewDto;
    /**
     * 
     * @type {any}
     * @memberof ProductDto
     */
    'offers'?: any;
}
/**
 * 
 * @export
 * @interface ProductNamesDto
 */
export interface ProductNamesDto {
    /**
     * H1 title
     * @type {string}
     * @memberof ProductNamesDto
     */
    'h1Title'?: string;
    /**
     * Meta description
     * @type {string}
     * @memberof ProductNamesDto
     */
    'metaDescription'?: string;
    /**
     * OpenGraph title
     * @type {string}
     * @memberof ProductNamesDto
     */
    'ogTitle'?: string;
    /**
     * OpenGraph description
     * @type {string}
     * @memberof ProductNamesDto
     */
    'ogDescription'?: string;
    /**
     * Twitter title
     * @type {string}
     * @memberof ProductNamesDto
     */
    'twitterTitle'?: string;
    /**
     * Twitter description
     * @type {string}
     * @memberof ProductNamesDto
     */
    'twitterDescription'?: string;
}
/**
 * 
 * @export
 * @interface ProductResourcesDto
 */
export interface ProductResourcesDto {
    /**
     * Image URLs
     * @type {Array<string>}
     * @memberof ProductResourcesDto
     */
    'images'?: Array<string>;
    /**
     * Video URLs
     * @type {Array<string>}
     * @memberof ProductResourcesDto
     */
    'videos'?: Array<string>;
    /**
     * PDF URLs
     * @type {Array<string>}
     * @memberof ProductResourcesDto
     */
    'pdfs'?: Array<string>;
    /**
     * Cover image URL
     * @type {string}
     * @memberof ProductResourcesDto
     */
    'coverPath'?: string;
}
/**
 * 
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {Array<Link>}
     * @memberof Property
     */
    'links'?: Array<Link>;
    /**
     * 
     * @type {Array<Attribute>}
     * @memberof Property
     */
    'attributes'?: Array<Attribute>;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface SortObject
 */
export interface SortObject {
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'empty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'sorted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'unsorted'?: boolean;
}
/**
 * 
 * @export
 * @interface Translation
 */
export interface Translation {
    /**
     * 
     * @type {Array<Link>}
     * @memberof Translation
     */
    'links'?: Array<Link>;
    /**
     * 
     * @type {string}
     * @memberof Translation
     */
    'language'?: string;
}
/**
 * 
 * @export
 * @interface Translations
 */
export interface Translations {
    /**
     * 
     * @type {Array<Link>}
     * @memberof Translations
     */
    'links'?: Array<Link>;
    /**
     * 
     * @type {Array<Translation>}
     * @memberof Translations
     */
    'translations'?: Array<Translation>;
    /**
     * 
     * @type {string}
     * @memberof Translations
     */
    'default'?: string;
}
/**
 * 
 * @export
 * @interface XwikiContentBlocDto
 */
export interface XwikiContentBlocDto {
    /**
     * 
     * @type {string}
     * @memberof XwikiContentBlocDto
     */
    'blocId'?: string;
    /**
     * 
     * @type {string}
     * @memberof XwikiContentBlocDto
     */
    'htmlContent'?: string;
    /**
     * 
     * @type {string}
     * @memberof XwikiContentBlocDto
     */
    'editLink'?: string;
}

/**
 * BlogApi - axios parameter creator
 * @export
 */
export const BlogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a single blog post identified by its slug.
         * @summary Get blog post
         * @param {string} slug Post slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('post', 'slug', slug)
            const localVarPath = `/blog/posts/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return paginated blog posts optionally filtered by tag.
         * @summary List blog posts
         * @param {string} [tag] Category/tag to filter on
         * @param {number} [pageNumber] Zero-based page index
         * @param {number} [pageSize] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posts: async (tag?: string, pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blog/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an RSS feed for all blog posts.
         * @summary Blog RSS feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rss: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blog/rss`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the list of available blog tags with post counts.
         * @summary List blog tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tags: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blog/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlogApi - functional programming interface
 * @export
 */
export const BlogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlogApiAxiosParamCreator(configuration)
    return {
        /**
         * Return a single blog post identified by its slug.
         * @summary Get blog post
         * @param {string} slug Post slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async post(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogPostDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.post(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogApi.post']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return paginated blog posts optionally filtered by tag.
         * @summary List blog posts
         * @param {string} [tag] Category/tag to filter on
         * @param {number} [pageNumber] Zero-based page index
         * @param {number} [pageSize] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async posts(tag?: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.posts(tag, pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogApi.posts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return an RSS feed for all blog posts.
         * @summary Blog RSS feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rss(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rss(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogApi.rss']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the list of available blog tags with post counts.
         * @summary List blog tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tags(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlogTagDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tags(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogApi.tags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlogApi - factory interface
 * @export
 */
export const BlogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlogApiFp(configuration)
    return {
        /**
         * Return a single blog post identified by its slug.
         * @summary Get blog post
         * @param {string} slug Post slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<BlogPostDto> {
            return localVarFp.post(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Return paginated blog posts optionally filtered by tag.
         * @summary List blog posts
         * @param {string} [tag] Category/tag to filter on
         * @param {number} [pageNumber] Zero-based page index
         * @param {number} [pageSize] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posts(tag?: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageDto> {
            return localVarFp.posts(tag, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Return an RSS feed for all blog posts.
         * @summary Blog RSS feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rss(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rss(options).then((request) => request(axios, basePath));
        },
        /**
         * Return the list of available blog tags with post counts.
         * @summary List blog tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tags(options?: RawAxiosRequestConfig): AxiosPromise<Array<BlogTagDto>> {
            return localVarFp.tags(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlogApi - object-oriented interface
 * @export
 * @class BlogApi
 * @extends {BaseAPI}
 */
export class BlogApi extends BaseAPI {
    /**
     * Return a single blog post identified by its slug.
     * @summary Get blog post
     * @param {string} slug Post slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public post(slug: string, options?: RawAxiosRequestConfig) {
        return BlogApiFp(this.configuration).post(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return paginated blog posts optionally filtered by tag.
     * @summary List blog posts
     * @param {string} [tag] Category/tag to filter on
     * @param {number} [pageNumber] Zero-based page index
     * @param {number} [pageSize] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public posts(tag?: string, pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BlogApiFp(this.configuration).posts(tag, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return an RSS feed for all blog posts.
     * @summary Blog RSS feed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public rss(options?: RawAxiosRequestConfig) {
        return BlogApiFp(this.configuration).rss(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the list of available blog tags with post counts.
     * @summary List blog tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogApi
     */
    public tags(options?: RawAxiosRequestConfig) {
        return BlogApiFp(this.configuration).tags(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentApi - axios parameter creator
 * @export
 */
export const ContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the HTML content of the given XWiki bloc.
         * @summary Get content bloc
         * @param {string} blocId XWiki page path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBloc: async (blocId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blocId' is not null or undefined
            assertParamExists('contentBloc', 'blocId', blocId)
            const localVarPath = `/blocs/{blocId}`
                .replace(`{${"blocId"}}`, encodeURIComponent(String(blocId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the rendered XWiki page along with metadata.
         * @summary Get XWiki page
         * @param {string} xwikiPageId XWiki page path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        page: async (xwikiPageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xwikiPageId' is not null or undefined
            assertParamExists('page', 'xwikiPageId', xwikiPageId)
            const localVarPath = `/pages/{xwikiPageId}`
                .replace(`{${"xwikiPageId"}}`, encodeURIComponent(String(xwikiPageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentApiAxiosParamCreator(configuration)
    return {
        /**
         * Return the HTML content of the given XWiki bloc.
         * @summary Get content bloc
         * @param {string} blocId XWiki page path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentBloc(blocId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XwikiContentBlocDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentBloc(blocId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentBloc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the rendered XWiki page along with metadata.
         * @summary Get XWiki page
         * @param {string} xwikiPageId XWiki page path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async page(xwikiPageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.page(xwikiPageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.page']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentApiFp(configuration)
    return {
        /**
         * Return the HTML content of the given XWiki bloc.
         * @summary Get content bloc
         * @param {string} blocId XWiki page path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentBloc(blocId: string, options?: RawAxiosRequestConfig): AxiosPromise<XwikiContentBlocDto> {
            return localVarFp.contentBloc(blocId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the rendered XWiki page along with metadata.
         * @summary Get XWiki page
         * @param {string} xwikiPageId XWiki page path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        page(xwikiPageId: string, options?: RawAxiosRequestConfig): AxiosPromise<FullPage> {
            return localVarFp.page(xwikiPageId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI {
    /**
     * Return the HTML content of the given XWiki bloc.
     * @summary Get content bloc
     * @param {string} blocId XWiki page path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public contentBloc(blocId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentBloc(blocId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the rendered XWiki page along with metadata.
     * @summary Get XWiki page
     * @param {string} xwikiPageId XWiki page path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public page(xwikiPageId: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).page(xwikiPageId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the list of fields available for aggregation.
         * @summary Get aggregatable fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatableFields: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/fields/aggregatable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the list of components that can be included in product responses.
         * @summary Get available components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        components: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/fields/components`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return high‑level product information and aggregated scores.
         * @summary Get product view
         * @param {number} gtin Global Trade Item Number (8–14 digit numeric code)
         * @param {Array<ProductIncludeEnum>} [include] Champs à inclure (peut se répéter)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        product: async (gtin: number, include?: Array<ProductIncludeEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gtin' is not null or undefined
            assertParamExists('product', 'gtin', gtin)
            const localVarPath = `/products/{gtin}`
                .replace(`{${"gtin"}}`, encodeURIComponent(String(gtin)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return paginated products.
         * @summary List products
         * @param {Array<ProductsIncludeEnum>} [include] Components to include (can be coma separated)
         * @param {number} [pageNumber] Zero-based page index
         * @param {number} [pageSize] Page size
         * @param {Array<ProductsSortEnum>} [sort] Sort criteria in the format: property,(asc|desc). 
         * @param {AggregationRequestDto} [aggregation] Aggregations definition as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        products: async (include?: Array<ProductsIncludeEnum>, pageNumber?: number, pageSize?: number, sort?: Array<ProductsSortEnum>, aggregation?: AggregationRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include) {
                localVarQueryParameter['include'] = include;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }

            if (aggregation !== undefined) {
                for (const [key, value] of Object.entries(aggregation)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the list of fields accepted by the sort parameter.
         * @summary Get sortable fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sortableFields: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/fields/sortable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * Return the list of fields available for aggregation.
         * @summary Get aggregatable fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregatableFields(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aggregatableFields(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.aggregatableFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the list of components that can be included in product responses.
         * @summary Get available components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async components(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.components(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.components']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return high‑level product information and aggregated scores.
         * @summary Get product view
         * @param {number} gtin Global Trade Item Number (8–14 digit numeric code)
         * @param {Array<ProductIncludeEnum>} [include] Champs à inclure (peut se répéter)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async product(gtin: number, include?: Array<ProductIncludeEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.product(gtin, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.product']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return paginated products.
         * @summary List products
         * @param {Array<ProductsIncludeEnum>} [include] Components to include (can be coma separated)
         * @param {number} [pageNumber] Zero-based page index
         * @param {number} [pageSize] Page size
         * @param {Array<ProductsSortEnum>} [sort] Sort criteria in the format: property,(asc|desc). 
         * @param {AggregationRequestDto} [aggregation] Aggregations definition as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async products(include?: Array<ProductsIncludeEnum>, pageNumber?: number, pageSize?: number, sort?: Array<ProductsSortEnum>, aggregation?: AggregationRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.products(include, pageNumber, pageSize, sort, aggregation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.products']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the list of fields accepted by the sort parameter.
         * @summary Get sortable fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sortableFields(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sortableFields(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.sortableFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * Return the list of fields available for aggregation.
         * @summary Get aggregatable fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatableFields(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.aggregatableFields(options).then((request) => request(axios, basePath));
        },
        /**
         * Return the list of components that can be included in product responses.
         * @summary Get available components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        components(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.components(options).then((request) => request(axios, basePath));
        },
        /**
         * Return high‑level product information and aggregated scores.
         * @summary Get product view
         * @param {number} gtin Global Trade Item Number (8–14 digit numeric code)
         * @param {Array<ProductIncludeEnum>} [include] Champs à inclure (peut se répéter)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        product(gtin: number, include?: Array<ProductIncludeEnum>, options?: RawAxiosRequestConfig): AxiosPromise<ProductDto> {
            return localVarFp.product(gtin, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Return paginated products.
         * @summary List products
         * @param {Array<ProductsIncludeEnum>} [include] Components to include (can be coma separated)
         * @param {number} [pageNumber] Zero-based page index
         * @param {number} [pageSize] Page size
         * @param {Array<ProductsSortEnum>} [sort] Sort criteria in the format: property,(asc|desc). 
         * @param {AggregationRequestDto} [aggregation] Aggregations definition as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        products(include?: Array<ProductsIncludeEnum>, pageNumber?: number, pageSize?: number, sort?: Array<ProductsSortEnum>, aggregation?: AggregationRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<PageDto> {
            return localVarFp.products(include, pageNumber, pageSize, sort, aggregation, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the list of fields accepted by the sort parameter.
         * @summary Get sortable fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sortableFields(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.sortableFields(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * Return the list of fields available for aggregation.
     * @summary Get aggregatable fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public aggregatableFields(options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).aggregatableFields(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the list of components that can be included in product responses.
     * @summary Get available components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public components(options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).components(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return high‑level product information and aggregated scores.
     * @summary Get product view
     * @param {number} gtin Global Trade Item Number (8–14 digit numeric code)
     * @param {Array<ProductIncludeEnum>} [include] Champs à inclure (peut se répéter)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public product(gtin: number, include?: Array<ProductIncludeEnum>, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).product(gtin, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return paginated products.
     * @summary List products
     * @param {Array<ProductsIncludeEnum>} [include] Components to include (can be coma separated)
     * @param {number} [pageNumber] Zero-based page index
     * @param {number} [pageSize] Page size
     * @param {Array<ProductsSortEnum>} [sort] Sort criteria in the format: property,(asc|desc). 
     * @param {AggregationRequestDto} [aggregation] Aggregations definition as JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public products(include?: Array<ProductsIncludeEnum>, pageNumber?: number, pageSize?: number, sort?: Array<ProductsSortEnum>, aggregation?: AggregationRequestDto, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).products(include, pageNumber, pageSize, sort, aggregation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the list of fields accepted by the sort parameter.
     * @summary Get sortable fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public sortableFields(options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).sortableFields(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ProductIncludeEnum = {
    Base: 'base',
    Names: 'names',
    Resources: 'resources',
    AiReview: 'aiReview',
    Offers: 'offers'
} as const;
export type ProductIncludeEnum = typeof ProductIncludeEnum[keyof typeof ProductIncludeEnum];
/**
 * @export
 */
export const ProductsIncludeEnum = {
    Base: 'base',
    Names: 'names',
    Resources: 'resources',
    AiReview: 'aiReview',
    Offers: 'offers'
} as const;
export type ProductsIncludeEnum = typeof ProductsIncludeEnum[keyof typeof ProductsIncludeEnum];
/**
 * @export
 */
export const ProductsSortEnum = {
    PriceMinPricePrice: 'price.minPrice.price',
    OffersCount: 'offersCount'
} as const;
export type ProductsSortEnum = typeof ProductsSortEnum[keyof typeof ProductsSortEnum];


