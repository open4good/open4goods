/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
import type { ProductResourcePdfInfoDto } from './ProductResourcePdfInfoDto';
import {
    ProductResourcePdfInfoDtoFromJSON,
    ProductResourcePdfInfoDtoFromJSONTyped,
    ProductResourcePdfInfoDtoToJSON,
    ProductResourcePdfInfoDtoToJSONTyped,
} from './ProductResourcePdfInfoDto';
import type { ProductResourceImageInfoDto } from './ProductResourceImageInfoDto';
import {
    ProductResourceImageInfoDtoFromJSON,
    ProductResourceImageInfoDtoFromJSONTyped,
    ProductResourceImageInfoDtoToJSON,
    ProductResourceImageInfoDtoToJSONTyped,
} from './ProductResourceImageInfoDto';

/**
 * 
 * @export
 * @interface ProductResourceDto
 */
export interface ProductResourceDto {
    /**
     * Resource URL
     * @type {string}
     * @memberof ProductResourceDto
     */
    url?: string;
    /**
     * Detected MIME type
     * @type {string}
     * @memberof ProductResourceDto
     */
    mimeType?: string;
    /**
     * Last update timestamp in epoch milliseconds
     * @type {number}
     * @memberof ProductResourceDto
     */
    timeStamp?: number;
    /**
     * Cache key used by the media pipeline
     * @type {string}
     * @memberof ProductResourceDto
     */
    cacheKey?: string;
    /**
     * Whether the resource has been evicted from the catalogue
     * @type {boolean}
     * @memberof ProductResourceDto
     */
    evicted?: boolean;
    /**
     * Whether the resource has been processed
     * @type {boolean}
     * @memberof ProductResourceDto
     */
    processed?: boolean;
    /**
     * Status assigned by the ingestion pipeline
     * @type {string}
     * @memberof ProductResourceDto
     */
    status?: ProductResourceDtoStatusEnum;
    /**
     * Size in bytes when known
     * @type {number}
     * @memberof ProductResourceDto
     */
    fileSize?: number;
    /**
     * File name extracted from the URL
     * @type {string}
     * @memberof ProductResourceDto
     */
    fileName?: string;
    /**
     * File extension
     * @type {string}
     * @memberof ProductResourceDto
     */
    extension?: string;
    /**
     * MD5 checksum when available
     * @type {string}
     * @memberof ProductResourceDto
     */
    md5?: string;
    /**
     * Resource type
     * @type {string}
     * @memberof ProductResourceDto
     */
    resourceType?: ProductResourceDtoResourceTypeEnum;
    /**
     * Additional image metadata
     * @type {ProductResourceImageInfoDto}
     * @memberof ProductResourceDto
     */
    imageInfo?: ProductResourceImageInfoDto;
    /**
     * Additional PDF metadata
     * @type {ProductResourcePdfInfoDto}
     * @memberof ProductResourceDto
     */
    pdfInfo?: ProductResourcePdfInfoDto;
    /**
     * Group identifier used to cluster similar images
     * @type {number}
     * @memberof ProductResourceDto
     */
    group?: number;
    /**
     * Datasource providing the resource
     * @type {string}
     * @memberof ProductResourceDto
     */
    datasourceName?: string;
    /**
     * Tags describing the resource
     * @type {Set<string>}
     * @memberof ProductResourceDto
     */
    tags?: Set<string>;
    /**
     * Hard tags describing the resource nature
     * @type {Set<string>}
     * @memberof ProductResourceDto
     */
    hardTags?: Set<ProductResourceDtoHardTagsEnum>;
}


/**
 * @export
 */
export const ProductResourceDtoStatusEnum = {
    Md5ChecksumFail: 'MD5_CHECKSUM_FAIL',
    ProtocolException: 'PROTOCOL_EXCEPTION',
    IoException: 'IO_EXCEPTION',
    NoMimeType: 'NO_MIME_TYPE',
    Md5Exclusion: 'MD5_EXCLUSION',
    Md5Duplicate: 'MD5_DUPLICATE',
    TooSmall: 'TOO_SMALL',
    CannotAnalyse: 'CANNOT_ANALYSE',
    PerceptivHashFail: 'PERCEPTIV_HASH_FAIL',
    PdfParsingError: 'PDF_PARSING_ERROR'
} as const;
export type ProductResourceDtoStatusEnum = typeof ProductResourceDtoStatusEnum[keyof typeof ProductResourceDtoStatusEnum];

/**
 * @export
 */
export const ProductResourceDtoResourceTypeEnum = {
    Image: 'IMAGE',
    Pdf: 'PDF',
    Unknown: 'UNKNOWN',
    Video: 'VIDEO'
} as const;
export type ProductResourceDtoResourceTypeEnum = typeof ProductResourceDtoResourceTypeEnum[keyof typeof ProductResourceDtoResourceTypeEnum];

/**
 * @export
 */
export const ProductResourceDtoHardTagsEnum = {
    AmazonPrimaryTag: 'AMAZON_PRIMARY_TAG',
    AmazonVariantTag: 'AMAZON_VARIANT_TAG',
    Primary: 'PRIMARY',
    RepairabilitySheet: 'REPAIRABILITY_SHEET',
    ProductSheet: 'PRODUCT_SHEET',
    Manual: 'MANUAL',
    InformationSheet: 'INFORMATION_SHEET',
    EnergyLabel: 'ENERGY_LABEL',
    Leaflet: 'LEAFLET'
} as const;
export type ProductResourceDtoHardTagsEnum = typeof ProductResourceDtoHardTagsEnum[keyof typeof ProductResourceDtoHardTagsEnum];


/**
 * Check if a given object implements the ProductResourceDto interface.
 */
export function instanceOfProductResourceDto(value: object): value is ProductResourceDto {
    return true;
}

export function ProductResourceDtoFromJSON(json: any): ProductResourceDto {
    return ProductResourceDtoFromJSONTyped(json, false);
}

export function ProductResourceDtoFromJSONTyped(json: any, ignoreDiscriminator: boolean): ProductResourceDto {
    if (json == null) {
        return json;
    }
    return {
        
        'url': json['url'] == null ? undefined : json['url'],
        'mimeType': json['mimeType'] == null ? undefined : json['mimeType'],
        'timeStamp': json['timeStamp'] == null ? undefined : json['timeStamp'],
        'cacheKey': json['cacheKey'] == null ? undefined : json['cacheKey'],
        'evicted': json['evicted'] == null ? undefined : json['evicted'],
        'processed': json['processed'] == null ? undefined : json['processed'],
        'status': json['status'] == null ? undefined : json['status'],
        'fileSize': json['fileSize'] == null ? undefined : json['fileSize'],
        'fileName': json['fileName'] == null ? undefined : json['fileName'],
        'extension': json['extension'] == null ? undefined : json['extension'],
        'md5': json['md5'] == null ? undefined : json['md5'],
        'resourceType': json['resourceType'] == null ? undefined : json['resourceType'],
        'imageInfo': json['imageInfo'] == null ? undefined : ProductResourceImageInfoDtoFromJSON(json['imageInfo']),
        'pdfInfo': json['pdfInfo'] == null ? undefined : ProductResourcePdfInfoDtoFromJSON(json['pdfInfo']),
        'group': json['group'] == null ? undefined : json['group'],
        'datasourceName': json['datasourceName'] == null ? undefined : json['datasourceName'],
        'tags': json['tags'] == null ? undefined : new Set(json['tags']),
        'hardTags': json['hardTags'] == null ? undefined : new Set(json['hardTags']),
    };
}

export function ProductResourceDtoToJSON(json: any): ProductResourceDto {
    return ProductResourceDtoToJSONTyped(json, false);
}

export function ProductResourceDtoToJSONTyped(value?: ProductResourceDto | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }

    return {
        
        'url': value['url'],
        'mimeType': value['mimeType'],
        'timeStamp': value['timeStamp'],
        'cacheKey': value['cacheKey'],
        'evicted': value['evicted'],
        'processed': value['processed'],
        'status': value['status'],
        'fileSize': value['fileSize'],
        'fileName': value['fileName'],
        'extension': value['extension'],
        'md5': value['md5'],
        'resourceType': value['resourceType'],
        'imageInfo': ProductResourceImageInfoDtoToJSON(value['imageInfo']),
        'pdfInfo': ProductResourcePdfInfoDtoToJSON(value['pdfInfo']),
        'group': value['group'],
        'datasourceName': value['datasourceName'],
        'tags': value['tags'] == null ? undefined : Array.from(value['tags'] as Set<any>),
        'hardTags': value['hardTags'] == null ? undefined : Array.from(value['hardTags'] as Set<any>),
    };
}

