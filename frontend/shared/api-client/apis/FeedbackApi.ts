/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  FeedbackErrorResponseDto,
  FeedbackIssueDto,
  FeedbackRemainingVotesDto,
  FeedbackSubmissionRequestDto,
  FeedbackSubmissionResponseDto,
  FeedbackVoteEligibilityDto,
  FeedbackVoteResponseDto,
} from '../models/index';
import {
    FeedbackErrorResponseDtoFromJSON,
    FeedbackErrorResponseDtoToJSON,
    FeedbackIssueDtoFromJSON,
    FeedbackIssueDtoToJSON,
    FeedbackRemainingVotesDtoFromJSON,
    FeedbackRemainingVotesDtoToJSON,
    FeedbackSubmissionRequestDtoFromJSON,
    FeedbackSubmissionRequestDtoToJSON,
    FeedbackSubmissionResponseDtoFromJSON,
    FeedbackSubmissionResponseDtoToJSON,
    FeedbackVoteEligibilityDtoFromJSON,
    FeedbackVoteEligibilityDtoToJSON,
    FeedbackVoteResponseDtoFromJSON,
    FeedbackVoteResponseDtoToJSON,
} from '../models/index';

export interface CanVoteRequest {
    domainLanguage: CanVoteDomainLanguageEnum;
}

export interface ListIssuesRequest {
    domainLanguage: ListIssuesDomainLanguageEnum;
    type?: ListIssuesTypeEnum;
}

export interface RemainingVotesRequest {
    domainLanguage: RemainingVotesDomainLanguageEnum;
}

export interface SubmitFeedbackRequest {
    domainLanguage: SubmitFeedbackDomainLanguageEnum;
    feedbackSubmissionRequestDto: FeedbackSubmissionRequestDto;
}

export interface VoteRequest {
    issueId: string;
    domainLanguage: VoteDomainLanguageEnum;
}

/**
 * 
 */
export class FeedbackApi extends runtime.BaseAPI {

    /**
     * Indicate whether the caller may still vote today.
     * Check voting eligibility
     */
    async canVoteRaw(requestParameters: CanVoteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeedbackVoteEligibilityDto>> {
        if (requestParameters['domainLanguage'] == null) {
            throw new runtime.RequiredError(
                'domainLanguage',
                'Required parameter "domainLanguage" was null or undefined when calling canVote().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['domainLanguage'] != null) {
            queryParameters['domainLanguage'] = requestParameters['domainLanguage'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/feedback/votes/can`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeedbackVoteEligibilityDtoFromJSON(jsonValue));
    }

    /**
     * Indicate whether the caller may still vote today.
     * Check voting eligibility
     */
    async canVote(requestParameters: CanVoteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeedbackVoteEligibilityDto> {
        const response = await this.canVoteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return GitHub issues labelled for feedback along with their vote counts.
     * List feedback issues
     */
    async listIssuesRaw(requestParameters: ListIssuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<FeedbackIssueDto>>> {
        if (requestParameters['domainLanguage'] == null) {
            throw new runtime.RequiredError(
                'domainLanguage',
                'Required parameter "domainLanguage" was null or undefined when calling listIssues().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['domainLanguage'] != null) {
            queryParameters['domainLanguage'] = requestParameters['domainLanguage'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/feedback/issues`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FeedbackIssueDtoFromJSON));
    }

    /**
     * Return GitHub issues labelled for feedback along with their vote counts.
     * List feedback issues
     */
    async listIssues(requestParameters: ListIssuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<FeedbackIssueDto>> {
        const response = await this.listIssuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the number of votes still available for the caller today.
     * Get remaining votes
     */
    async remainingVotesRaw(requestParameters: RemainingVotesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeedbackRemainingVotesDto>> {
        if (requestParameters['domainLanguage'] == null) {
            throw new runtime.RequiredError(
                'domainLanguage',
                'Required parameter "domainLanguage" was null or undefined when calling remainingVotes().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['domainLanguage'] != null) {
            queryParameters['domainLanguage'] = requestParameters['domainLanguage'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/feedback/votes/remaining`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeedbackRemainingVotesDtoFromJSON(jsonValue));
    }

    /**
     * Return the number of votes still available for the caller today.
     * Get remaining votes
     */
    async remainingVotes(requestParameters: RemainingVotesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeedbackRemainingVotesDto> {
        const response = await this.remainingVotesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Verify hCaptcha token then create a GitHub issue representing the feedback.
     * Submit a feedback entry
     */
    async submitFeedbackRaw(requestParameters: SubmitFeedbackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeedbackSubmissionResponseDto>> {
        if (requestParameters['domainLanguage'] == null) {
            throw new runtime.RequiredError(
                'domainLanguage',
                'Required parameter "domainLanguage" was null or undefined when calling submitFeedback().'
            );
        }

        if (requestParameters['feedbackSubmissionRequestDto'] == null) {
            throw new runtime.RequiredError(
                'feedbackSubmissionRequestDto',
                'Required parameter "feedbackSubmissionRequestDto" was null or undefined when calling submitFeedback().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['domainLanguage'] != null) {
            queryParameters['domainLanguage'] = requestParameters['domainLanguage'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/feedback`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FeedbackSubmissionRequestDtoToJSON(requestParameters['feedbackSubmissionRequestDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeedbackSubmissionResponseDtoFromJSON(jsonValue));
    }

    /**
     * Verify hCaptcha token then create a GitHub issue representing the feedback.
     * Submit a feedback entry
     */
    async submitFeedback(requestParameters: SubmitFeedbackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeedbackSubmissionResponseDto> {
        const response = await this.submitFeedbackRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a vote for the provided GitHub issue if quotas allow it.
     * Vote on a feedback issue
     */
    async voteRaw(requestParameters: VoteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FeedbackVoteResponseDto>> {
        if (requestParameters['issueId'] == null) {
            throw new runtime.RequiredError(
                'issueId',
                'Required parameter "issueId" was null or undefined when calling vote().'
            );
        }

        if (requestParameters['domainLanguage'] == null) {
            throw new runtime.RequiredError(
                'domainLanguage',
                'Required parameter "domainLanguage" was null or undefined when calling vote().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['issueId'] != null) {
            queryParameters['issueId'] = requestParameters['issueId'];
        }

        if (requestParameters['domainLanguage'] != null) {
            queryParameters['domainLanguage'] = requestParameters['domainLanguage'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/feedback/vote`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeedbackVoteResponseDtoFromJSON(jsonValue));
    }

    /**
     * Register a vote for the provided GitHub issue if quotas allow it.
     * Vote on a feedback issue
     */
    async vote(requestParameters: VoteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FeedbackVoteResponseDto> {
        const response = await this.voteRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CanVoteDomainLanguageEnum = {
    Fr: 'fr',
    En: 'en'
} as const;
export type CanVoteDomainLanguageEnum = typeof CanVoteDomainLanguageEnum[keyof typeof CanVoteDomainLanguageEnum];
/**
 * @export
 */
export const ListIssuesDomainLanguageEnum = {
    Fr: 'fr',
    En: 'en'
} as const;
export type ListIssuesDomainLanguageEnum = typeof ListIssuesDomainLanguageEnum[keyof typeof ListIssuesDomainLanguageEnum];
/**
 * @export
 */
export const ListIssuesTypeEnum = {
    Idea: 'IDEA',
    Bug: 'BUG'
} as const;
export type ListIssuesTypeEnum = typeof ListIssuesTypeEnum[keyof typeof ListIssuesTypeEnum];
/**
 * @export
 */
export const RemainingVotesDomainLanguageEnum = {
    Fr: 'fr',
    En: 'en'
} as const;
export type RemainingVotesDomainLanguageEnum = typeof RemainingVotesDomainLanguageEnum[keyof typeof RemainingVotesDomainLanguageEnum];
/**
 * @export
 */
export const SubmitFeedbackDomainLanguageEnum = {
    Fr: 'fr',
    En: 'en'
} as const;
export type SubmitFeedbackDomainLanguageEnum = typeof SubmitFeedbackDomainLanguageEnum[keyof typeof SubmitFeedbackDomainLanguageEnum];
/**
 * @export
 */
export const VoteDomainLanguageEnum = {
    Fr: 'fr',
    En: 'en'
} as const;
export type VoteDomainLanguageEnum = typeof VoteDomainLanguageEnum[keyof typeof VoteDomainLanguageEnum];
